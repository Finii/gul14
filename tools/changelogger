#!/bin/sh
#
# Autogenerate the debian/changelog from git tags
# The output will be further configured by meson
#
# This is version 1.1 "Anteater", changed 17 Dec 2018
#
# A git version tag have the form 'name_M_m_p' where M, m and p are
# positive integers with the semantic version number. name is a non-
# numeric string that is ignored and must be specified with parameter tag_prefix.
#
# Parameter tag_prefix is used to find the tags that denote the version this script
# shall use. It is evaluated by git for-each-ref and usually needs to end in a wildcard
# character. This are not regexes.
#
# Note that the matching is rather sloppy, this only works when no
# strange tags are created.

while getopts ":hptC:" opt; do
	case $opt in
	h)
		hint=1;;
	p)
		pack_vers=1;;
	t)
		show_tags=' %d';;
	C)
		workdir="-C ${OPTARG}";;
	\?)
		echo "Invalid option: -$OPTARG"
		hint=1;;
	esac
done
shift $((OPTIND-1))

if [ -n "${hint}" -o $# -ne 2 ]; then
	echo "Usage: `basename "$0"` [options] tag_prefix output_file"
	echo
	echo "       Options:"
	echo "          -h          Show help (this)"
	echo "          -p          Enable packet name versioning"
	echo "          -t          Show tags in commit messages"
	echo "          -C path     Change to path before doing anything"
	exit 1
fi

tag_pre=$1
outfile=$2
printf "" > ${outfile}

# Collect all relevant information
# HEAD, TAGS..., ROOT-commit
allcommits=`git ${workdir} log --format="ref='%H' aut='%an' email='<%ae>' dat='%cD'"`
head=`echo "${allcommits}" | head -n 1`
root=`echo "${allcommits}" | tail -n 1`
tags=`git ${workdir} for-each-ref --shell --sort=-v:refname --format=ref="%(refname) aut=%(taggername) email=%(taggeremail) dat=%(taggerdate:rfc)" "refs/tags/${tag_pre}" --merged`

# find out if HEAD is a tagged commit
top_tag=`git ${workdir} for-each-ref --sort=-v:refname --count=1 --format='%(refname)' "refs/tags/${tag_pre}" --merged`
patches=`git ${workdir} rev-list ${top_tag}..HEAD --count`
if [ ${patches} -lt 1 ]; then
	entry_begin=`echo ${tags} | head -n 1`
	tags=`echo ${tags} | tail -n +1`
fi

# prepare for first loop iteration
entry_begin=${head}
eval "${entry_begin}"
# The top entry will get the version number always from meson to make sure we do
# not go wrong, ever. If the following entries have wrong versions this is just
# a cosmetic glitch
header="@NAME@ (@VERSION@) stable; urgency=low"

printf "${tags}\n${root}\n" | \
while read entry_next; do
	footer=" -- ${aut} ${email}  ${dat}"
	head_ref=${ref}
	eval "${entry_next}"
	printf "${header}\n" >> ${outfile}
	eval "git ${workdir} log --format='  * %s${show_tags}' ${ref}..${head_ref} | sed 's/ *$//g'" >> ${outfile}
	printf "${footer}\n\n" >> ${outfile}
	# prepare for next loop iteration
	# (the header of the first iteration is different; it takes direct meson variables)
	version=`echo ${ref} | sed 's/[^0-9]*//;s/[^0-9]/./g;s/^\([0-9]\+\.[0-9]\+\)$/\1.0/'`
	vername=`echo ${ref} | sed 's/[^0-9]*//;s/[^0-9]/-/g'`
	if [ -n "${pack_vers}" ]; then
		header="@NAME-BASE@-${vername} (${version}) stable; urgency=low"
	else
		header="@NAME@ (${version}) stable; urgency=low"
	fi
done
