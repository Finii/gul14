<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++14: gul14 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul14.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++14
   &#160;<span id="projectnumber">2.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gul14 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace <a class="el" href="namespacegul14.html" title="Namespace gul14 contains all functions and classes of the General Utility Library.">gul14</a> contains all functions and classes of the General Utility Library. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of chars or char-like objects.  <a href="classgul14_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string view that can automatically convert numbers into strings.  <a href="classgul14_1_1ConvertingStringView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1FailToInstantiate.html">FailToInstantiate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to debug types.  <a href="classgul14_1_1FailToInstantiate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1FinalAction.html">FinalAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgul14_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> allows us to execute something if the <a class="el" href="classgul14_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> object leaves the scope.  <a href="classgul14_1_1FinalAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object used to enable a convenient syntax to dump things to a stream.  <a href="classgul14_1_1HexdumpParameterForward.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgul14_1_1IsContainerLike.html">IsContainerLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type trait object to determine if a type is a container.  <a href="structgul14_1_1IsContainerLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgul14_1_1MinMax.html">MinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that is designed to holds two values: minimum and maximum of something.  <a href="structgul14_1_1MinMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template that can either contain a value of a certain type or not.  <a href="classgul14_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1optional_3_01T_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template that can either contain a value of a certain type or not.  <a href="classgul14_1_1optional_3_01T_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the back.  <a href="classgul14_1_1SlidingBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBufferExposed.html">SlidingBufferExposed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> that exposes the underlying container through its iterator interface.  <a href="classgul14_1_1SlidingBufferExposed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable container with contiguous storage that can hold a specified number of elements without allocating memory on the heap.  <a href="classgul14_1_1SmallVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of objects.  <a href="classgul14_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1StandardDeviationMean.html">StandardDeviationMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct holding a standard deviation and a mean value.  <a href="classgul14_1_1StandardDeviationMean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1Trigger.html">Trigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows sending triggers and waiting for them across different threads.  <a href="classgul14_1_1Trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afc1d6e2f0688dc334f92653ae1f7a5fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc1d6e2f0688dc334f92653ae1f7a5fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#afc1d6e2f0688dc334f92653ae1f7a5fa">BitFunctionReturnType</a> = std::enable_if_t&lt; std::is_integral&lt; T &gt;::value and not std::is_same&lt; std::decay_t&lt; T &gt;, bool &gt;::value, std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:afc1d6e2f0688dc334f92653ae1f7a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of the bit manipulation functions.  <a href="namespacegul14.html#afc1d6e2f0688dc334f92653ae1f7a5fa">More...</a><br /></td></tr>
<tr class="separator:afc1d6e2f0688dc334f92653ae1f7a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d63134a0418f5318eb5857f6467502"><td class="memItemLeft" align="right" valign="top"><a id="a28d63134a0418f5318eb5857f6467502"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a28d63134a0418f5318eb5857f6467502">statistics_result_type</a> = double</td></tr>
<tr class="memdesc:a28d63134a0418f5318eb5857f6467502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to return statistic properties. <br /></td></tr>
<tr class="separator:a28d63134a0418f5318eb5857f6467502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebb24dac7ab090d9145ff49abab9013"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> = <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a6ebb24dac7ab090d9145ff49abab9013"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of chars.  <a href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">More...</a><br /></td></tr>
<tr class="separator:a6ebb24dac7ab090d9145ff49abab9013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b2b4a816dea6586aea6e4e19dcf7a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a95b2b4a816dea6586aea6e4e19dcf7a5">u16string_view</a> = <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:a95b2b4a816dea6586aea6e4e19dcf7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of char16_ts.  <a href="namespacegul14.html#a95b2b4a816dea6586aea6e4e19dcf7a5">More...</a><br /></td></tr>
<tr class="separator:a95b2b4a816dea6586aea6e4e19dcf7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0414875154e5452182cfb76785d377bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a0414875154e5452182cfb76785d377bc">u32string_view</a> = <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:a0414875154e5452182cfb76785d377bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of char32_ts.  <a href="namespacegul14.html#a0414875154e5452182cfb76785d377bc">More...</a><br /></td></tr>
<tr class="separator:a0414875154e5452182cfb76785d377bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855c927b58e1d1854a727b815e8ce1c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a855c927b58e1d1854a727b815e8ce1c4">wstring_view</a> = <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:a855c927b58e1d1854a727b815e8ce1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of wchar_ts.  <a href="namespacegul14.html#a855c927b58e1d1854a727b815e8ce1c4">More...</a><br /></td></tr>
<tr class="separator:a855c927b58e1d1854a727b815e8ce1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2a276f44539a7a7e2d88c872486e2ff9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a> { <b>keep_front_elements</b>, 
<b>keep_back_elements</b>
 }</td></tr>
<tr class="memdesc:a2a276f44539a7a7e2d88c872486e2ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how a SlidingBuffer handles decreases of its size.  <a href="namespacegul14.html#a2a276f44539a7a7e2d88c872486e2ff9">More...</a><br /></td></tr>
<tr class="separator:a2a276f44539a7a7e2d88c872486e2ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65b66729b7fb79ec00fcff24eb3fcf13"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned, typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a65b66729b7fb79ec00fcff24eb3fcf13"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a65b66729b7fb79ec00fcff24eb3fcf13">bit_set</a> (unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:a65b66729b7fb79ec00fcff24eb3fcf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bit in an integral type.  <a href="namespacegul14.html#a65b66729b7fb79ec00fcff24eb3fcf13">More...</a><br /></td></tr>
<tr class="separator:a65b66729b7fb79ec00fcff24eb3fcf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf64b788578bb3caa75680663677de9a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:acf64b788578bb3caa75680663677de9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#acf64b788578bb3caa75680663677de9a">bit_set</a> (T previous, unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:acf64b788578bb3caa75680663677de9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bit in an integral value.  <a href="namespacegul14.html#acf64b788578bb3caa75680663677de9a">More...</a><br /></td></tr>
<tr class="separator:acf64b788578bb3caa75680663677de9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad702fe0f272a70a4da6f63de30bd295"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aad702fe0f272a70a4da6f63de30bd295"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aad702fe0f272a70a4da6f63de30bd295">bit_reset</a> (T previous, unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:aad702fe0f272a70a4da6f63de30bd295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a bit in an integral value.  <a href="namespacegul14.html#aad702fe0f272a70a4da6f63de30bd295">More...</a><br /></td></tr>
<tr class="separator:aad702fe0f272a70a4da6f63de30bd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b584ad55786999bbb6f822345d7cfef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6b584ad55786999bbb6f822345d7cfef"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a6b584ad55786999bbb6f822345d7cfef">bit_flip</a> (T previous, unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:a6b584ad55786999bbb6f822345d7cfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip a bit in an integral value.  <a href="namespacegul14.html#a6b584ad55786999bbb6f822345d7cfef">More...</a><br /></td></tr>
<tr class="separator:a6b584ad55786999bbb6f822345d7cfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908d23e591803cc8c98d63ba04ff0f1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a908d23e591803cc8c98d63ba04ff0f1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a908d23e591803cc8c98d63ba04ff0f1a">bit_test</a> (T bits, unsigned bit) noexcept</td></tr>
<tr class="memdesc:a908d23e591803cc8c98d63ba04ff0f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a bit in an integral value.  <a href="namespacegul14.html#a908d23e591803cc8c98d63ba04ff0f1a">More...</a><br /></td></tr>
<tr class="separator:a908d23e591803cc8c98d63ba04ff0f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd41f38bbdde29c2a0ef7e5864d9052"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii</a> (char c) noexcept</td></tr>
<tr class="memdesc:a5dd41f38bbdde29c2a0ef7e5864d9052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ASCII lowercase equivalent of the given character (or the unchanged character, if it is not an ASCII letter).  <a href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">More...</a><br /></td></tr>
<tr class="separator:a5dd41f38bbdde29c2a0ef7e5864d9052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6d216830d66a060c66ceb8e18f5e90"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a9d6d216830d66a060c66ceb8e18f5e90">lowercase_ascii</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a> str)</td></tr>
<tr class="memdesc:a9d6d216830d66a060c66ceb8e18f5e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the given string in which all ASCII characters are replaced by their lowercase equivalents.  <a href="namespacegul14.html#a9d6d216830d66a060c66ceb8e18f5e90">More...</a><br /></td></tr>
<tr class="separator:a9d6d216830d66a060c66ceb8e18f5e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdcecf4d343173209f4bcb5fee32bff"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a3cdcecf4d343173209f4bcb5fee32bff">lowercase_ascii_inplace</a> (std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:a3cdcecf4d343173209f4bcb5fee32bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all ASCII characters in a string by their lowercase equivalents.  <a href="namespacegul14.html#a3cdcecf4d343173209f4bcb5fee32bff">More...</a><br /></td></tr>
<tr class="separator:a3cdcecf4d343173209f4bcb5fee32bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917cd7027e563ab68940810b15daaa0a"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a">uppercase_ascii</a> (char c) noexcept</td></tr>
<tr class="memdesc:a917cd7027e563ab68940810b15daaa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ASCII uppercase equivalent of the given character (or the unchanged character, if it is not an ASCII letter).  <a href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a">More...</a><br /></td></tr>
<tr class="separator:a917cd7027e563ab68940810b15daaa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3dd7d06bd977bcf832d7d9f00c9f0a"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a6d3dd7d06bd977bcf832d7d9f00c9f0a">uppercase_ascii</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a> str)</td></tr>
<tr class="memdesc:a6d3dd7d06bd977bcf832d7d9f00c9f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the given string in which all ASCII characters are replaced by their uppercase equivalents.  <a href="namespacegul14.html#a6d3dd7d06bd977bcf832d7d9f00c9f0a">More...</a><br /></td></tr>
<tr class="separator:a6d3dd7d06bd977bcf832d7d9f00c9f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d4383c549025201f317b6cce4c781"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#af94d4383c549025201f317b6cce4c781">uppercase_ascii_inplace</a> (std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:af94d4383c549025201f317b6cce4c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all ASCII characters in a string by their uppercase equivalents.  <a href="namespacegul14.html#af94d4383c549025201f317b6cce4c781">More...</a><br /></td></tr>
<tr class="separator:af94d4383c549025201f317b6cce4c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64e01233c1c469a698c36c9e2f89079"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079">cat</a> ()</td></tr>
<tr class="memdesc:ad64e01233c1c469a698c36c9e2f89079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently concatenate an arbitrary number of strings and numbers.  <a href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079">More...</a><br /></td></tr>
<tr class="separator:ad64e01233c1c469a698c36c9e2f89079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c7a3d661fe67ea5caf4911298c890e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa9c7a3d661fe67ea5caf4911298c890e">cat</a> (const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s)</td></tr>
<tr class="separator:aa9c7a3d661fe67ea5caf4911298c890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac1958ae0fa576e1135a5f30ce7c3e2"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aaac1958ae0fa576e1135a5f30ce7c3e2">cat</a> (const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s1, const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s2)</td></tr>
<tr class="separator:aaac1958ae0fa576e1135a5f30ce7c3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619aa48a0c092249f1cfd5e853526783"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a619aa48a0c092249f1cfd5e853526783">cat</a> (const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s1, const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s2, const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s3)</td></tr>
<tr class="separator:a619aa48a0c092249f1cfd5e853526783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb6e8fb55a42007d2febd6cd7ae8d7a"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#afbb6e8fb55a42007d2febd6cd7ae8d7a">cat</a> (std::initializer_list&lt; <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &gt; pieces)</td></tr>
<tr class="separator:afbb6e8fb55a42007d2febd6cd7ae8d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f160d726ecd0581d66e87d34250f3dd"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = std::enable_if_t&lt;(sizeof...(Args) &gt; 3)&gt;&gt; </td></tr>
<tr class="memitem:a8f160d726ecd0581d66e87d34250f3dd"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a8f160d726ecd0581d66e87d34250f3dd">cat</a> (const Args &amp;... args)</td></tr>
<tr class="separator:a8f160d726ecd0581d66e87d34250f3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881f0f6e3e283fb7558eaa336020cfdf"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a881f0f6e3e283fb7558eaa336020cfdf">escape</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> in)</td></tr>
<tr class="memdesc:a881f0f6e3e283fb7558eaa336020cfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string that looks like an ASCII-only C string literal of the input string.  <a href="namespacegul14.html#a881f0f6e3e283fb7558eaa336020cfdf">More...</a><br /></td></tr>
<tr class="separator:a881f0f6e3e283fb7558eaa336020cfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b4d247d8e814c42202713e3c4272b0"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa0b4d247d8e814c42202713e3c4272b0">unescape</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> in)</td></tr>
<tr class="memdesc:aa0b4d247d8e814c42202713e3c4272b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a string with escaped characters to get the original string back.  <a href="namespacegul14.html#aa0b4d247d8e814c42202713e3c4272b0">More...</a><br /></td></tr>
<tr class="separator:aa0b4d247d8e814c42202713e3c4272b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351c9c060eb9cefc28793e11d3932a5"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4351c9c060eb9cefc28793e11d3932a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1FinalAction.html">FinalAction</a>&lt; typename std::decay_t&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a4351c9c060eb9cefc28793e11d3932a5">finally</a> (F &amp;&amp;f) noexcept</td></tr>
<tr class="memdesc:a4351c9c060eb9cefc28793e11d3932a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacegul14.html#a4351c9c060eb9cefc28793e11d3932a5" title="finally() - convenience function to generate a FinalAction">finally()</a> - convenience function to generate a <a class="el" href="classgul14_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a>  <a href="namespacegul14.html#a4351c9c060eb9cefc28793e11d3932a5">More...</a><br /></td></tr>
<tr class="separator:a4351c9c060eb9cefc28793e11d3932a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad9d1a1cee23214a61491bfc8171595"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename  = std::enable_if_t&lt;detail::IsHexDumpIterator&lt;IteratorT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2ad9d1a1cee23214a61491bfc8171595"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">hexdump</a> (IteratorT begin, IteratorT end, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:a2ad9d1a1cee23214a61491bfc8171595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a hexdump of a data range and return it as a string.  <a href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">More...</a><br /></td></tr>
<tr class="separator:a2ad9d1a1cee23214a61491bfc8171595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d057910c13cf2965109f1f5698a6c42"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8d057910c13cf2965109f1f5698a6c42"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a8d057910c13cf2965109f1f5698a6c42">hexdump</a> (const ContainerT &amp;cont, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:a8d057910c13cf2965109f1f5698a6c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#a8d057910c13cf2965109f1f5698a6c42">More...</a><br /></td></tr>
<tr class="separator:a8d057910c13cf2965109f1f5698a6c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b2d42f1a3c17d56d8b4fa8dfddbf9b"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename  = std::enable_if_t&lt;detail::IsHexDumpIterator&lt;IteratorT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad3b2d42f1a3c17d56d8b4fa8dfddbf9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt; const IteratorT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">hexdump_stream</a> (const IteratorT &amp;begin, const IteratorT &amp;end, std::string prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:ad3b2d42f1a3c17d56d8b4fa8dfddbf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a hexdump of a data range that can be efficiently written to a stream using operator&lt;&lt;.  <a href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">More...</a><br /></td></tr>
<tr class="separator:ad3b2d42f1a3c17d56d8b4fa8dfddbf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712f6744dc70db3fa371397b3378d87c"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a712f6744dc70db3fa371397b3378d87c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt; const decltype(std::declval&lt; ContainerT &gt;).cbegin())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a712f6744dc70db3fa371397b3378d87c">hexdump_stream</a> (const ContainerT &amp;cont, std::string prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:a712f6744dc70db3fa371397b3378d87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#a712f6744dc70db3fa371397b3378d87c">More...</a><br /></td></tr>
<tr class="separator:a712f6744dc70db3fa371397b3378d87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cb3c0cf75996829712e5849d3dd878"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value,        decltype(HexdumpParameterForward&lt;decltype(std::declval&lt;ContainerT&gt;().cbegin()),                     ContainerT&gt; {}, 0)&gt;&gt; </td></tr>
<tr class="memitem:ac7cb3c0cf75996829712e5849d3dd878"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt; decltype(std::declval&lt; ContainerT &gt;).cbegin()), ContainerT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ac7cb3c0cf75996829712e5849d3dd878">hexdump_stream</a> (ContainerT &amp;&amp;cont, std::string prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:ac7cb3c0cf75996829712e5849d3dd878"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#ac7cb3c0cf75996829712e5849d3dd878">More...</a><br /></td></tr>
<tr class="separator:ac7cb3c0cf75996829712e5849d3dd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6eed5ed768613f3680866905ca82b9"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </td></tr>
<tr class="memitem:a0e6eed5ed768613f3680866905ca82b9"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9">split</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> text, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:a0e6eed5ed768613f3680866905ca82b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in a container.  <a href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9">More...</a><br /></td></tr>
<tr class="separator:a0e6eed5ed768613f3680866905ca82b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99682f92a890dcdc6cfc194142a2203f"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </td></tr>
<tr class="memitem:a99682f92a890dcdc6cfc194142a2203f"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a99682f92a890dcdc6cfc194142a2203f">split</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> text, const std::regex &amp;delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:a99682f92a890dcdc6cfc194142a2203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a string at all occurrences of a delimiter described by a regular expression, returning the strings between the delimiters in a container.  <a href="namespacegul14.html#a99682f92a890dcdc6cfc194142a2203f">More...</a><br /></td></tr>
<tr class="separator:a99682f92a890dcdc6cfc194142a2203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71226668835d574ccad136939940191f"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;string_view&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </td></tr>
<tr class="memitem:a71226668835d574ccad136939940191f"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a71226668835d574ccad136939940191f">split_sv</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> text, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:a71226668835d574ccad136939940191f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in a vector.  <a href="namespacegul14.html#a71226668835d574ccad136939940191f">More...</a><br /></td></tr>
<tr class="separator:a71226668835d574ccad136939940191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b05ef3db1b337691307dada4bb755aa"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer &gt; </td></tr>
<tr class="memitem:a0b05ef3db1b337691307dada4bb755aa"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa">join</a> (const StringContainer &amp;parts, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> glue)</td></tr>
<tr class="memdesc:a0b05ef3db1b337691307dada4bb755aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate all strings in a range, placing a delimiter between them.  <a href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa">More...</a><br /></td></tr>
<tr class="separator:a0b05ef3db1b337691307dada4bb755aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a75d4171ca190a68f266d5a6c364f9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a00a75d4171ca190a68f266d5a6c364f9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a00a75d4171ca190a68f266d5a6c364f9">join</a> (Iterator begin, Iterator end, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> glue)</td></tr>
<tr class="memdesc:a00a75d4171ca190a68f266d5a6c364f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate all strings in a range, placing a delimiter between them.  <a href="namespacegul14.html#a00a75d4171ca190a68f266d5a6c364f9">More...</a><br /></td></tr>
<tr class="separator:a00a75d4171ca190a68f266d5a6c364f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e71867d1a27d723ee0c2a3bcd7761c"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a02e71867d1a27d723ee0c2a3bcd7761c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c">abs</a> (ValueT n) noexcept -&gt; std::enable_if_t&lt; std::is_unsigned&lt; ValueT &gt;::value, ValueT &gt;</td></tr>
<tr class="memdesc:a02e71867d1a27d723ee0c2a3bcd7761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a number.  <a href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c">More...</a><br /></td></tr>
<tr class="separator:a02e71867d1a27d723ee0c2a3bcd7761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac147ccba8179827a34b584d6a7d11ac9"><td class="memTemplParams" colspan="2">template&lt;typename NumT , typename OrderT , typename  = std::enable_if_t&lt;        std::is_arithmetic&lt;NumT&gt;::value        and std::is_arithmetic&lt;OrderT&gt;::value    &gt;&gt; </td></tr>
<tr class="memitem:ac147ccba8179827a34b584d6a7d11ac9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ac147ccba8179827a34b584d6a7d11ac9">within_orders</a> (const NumT a, const NumT b, const OrderT orders) noexcept(false)</td></tr>
<tr class="memdesc:ac147ccba8179827a34b584d6a7d11ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two numbers are almost equal, comparing only some significant digits.  <a href="namespacegul14.html#ac147ccba8179827a34b584d6a7d11ac9">More...</a><br /></td></tr>
<tr class="separator:ac147ccba8179827a34b584d6a7d11ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a06029dccf60523519d5a22a71ac361"><td class="memTemplParams" colspan="2">template&lt;typename NumT &gt; </td></tr>
<tr class="memitem:a3a06029dccf60523519d5a22a71ac361"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a3a06029dccf60523519d5a22a71ac361">within_abs</a> (NumT a, NumT b, NumT tol) noexcept</td></tr>
<tr class="memdesc:a3a06029dccf60523519d5a22a71ac361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two numbers are almost equal, allowing for an absolute difference.  <a href="namespacegul14.html#a3a06029dccf60523519d5a22a71ac361">More...</a><br /></td></tr>
<tr class="separator:a3a06029dccf60523519d5a22a71ac361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7886cf179298ea422806b253f0bb0c"><td class="memTemplParams" colspan="2">template&lt;typename NumT , typename  = std::enable_if_t&lt;std::is_floating_point&lt;NumT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6c7886cf179298ea422806b253f0bb0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a6c7886cf179298ea422806b253f0bb0c">within_ulp</a> (NumT a, NumT b, unsigned int ulp)</td></tr>
<tr class="memdesc:a6c7886cf179298ea422806b253f0bb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two numbers are almost equal, allowing for a difference of a given number of units-in-the-last-place (ULPs).  <a href="namespacegul14.html#a6c7886cf179298ea422806b253f0bb0c">More...</a><br /></td></tr>
<tr class="separator:a6c7886cf179298ea422806b253f0bb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5967a0b377c9d4b3791db8e2e20a3"><td class="memTemplParams" colspan="2">template&lt;class NumT &gt; </td></tr>
<tr class="memitem:ac1b5967a0b377c9d4b3791db8e2e20a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr const NumT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ac1b5967a0b377c9d4b3791db8e2e20a3">clamp</a> (const NumT &amp;v, const NumT &amp;lo, const NumT &amp;hi)</td></tr>
<tr class="memdesc:ac1b5967a0b377c9d4b3791db8e2e20a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce a value to be within a given range.  <a href="namespacegul14.html#ac1b5967a0b377c9d4b3791db8e2e20a3">More...</a><br /></td></tr>
<tr class="separator:ac1b5967a0b377c9d4b3791db8e2e20a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee09fca8383e6c5b1b172cf3e0740273"><td class="memTemplParams" colspan="2">template&lt;class NumT , class Compare &gt; </td></tr>
<tr class="memitem:aee09fca8383e6c5b1b172cf3e0740273"><td class="memTemplItemLeft" align="right" valign="top">constexpr const NumT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aee09fca8383e6c5b1b172cf3e0740273">clamp</a> (const NumT &amp;v, const NumT &amp;lo, const NumT &amp;hi, Compare comp)</td></tr>
<tr class="memdesc:aee09fca8383e6c5b1b172cf3e0740273"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#aee09fca8383e6c5b1b172cf3e0740273">More...</a><br /></td></tr>
<tr class="separator:aee09fca8383e6c5b1b172cf3e0740273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9801de6999c42b6e2987a55532057a4c"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a9801de6999c42b6e2987a55532057a4c">replace</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> haystack, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> needle, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> hammer)</td></tr>
<tr class="memdesc:a9801de6999c42b6e2987a55532057a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string within another string, returning the result as a std::string.  <a href="namespacegul14.html#a9801de6999c42b6e2987a55532057a4c">More...</a><br /></td></tr>
<tr class="separator:a9801de6999c42b6e2987a55532057a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9ff5d5ab6febb6c74a83e6442c2cd1"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a5a9ff5d5ab6febb6c74a83e6442c2cd1">replace_inplace</a> (std::string &amp;haystack, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> needle, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> hammer)</td></tr>
<tr class="memdesc:a5a9ff5d5ab6febb6c74a83e6442c2cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string within another string in-place.  <a href="namespacegul14.html#a5a9ff5d5ab6febb6c74a83e6442c2cd1">More...</a><br /></td></tr>
<tr class="separator:a5a9ff5d5ab6febb6c74a83e6442c2cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4074913afff7c8698358785771ab61db"><td class="memTemplParams" colspan="2">template&lt;typename ElementT , size_t in_capacity&gt; </td></tr>
<tr class="memitem:a4074913afff7c8698358785771ab61db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a4074913afff7c8698358785771ab61db">swap</a> (<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;a, <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;b)</td></tr>
<tr class="memdesc:a4074913afff7c8698358785771ab61db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the contents of one <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with those of another one.  <a href="namespacegul14.html#a4074913afff7c8698358785771ab61db">More...</a><br /></td></tr>
<tr class="separator:a4074913afff7c8698358785771ab61db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac688ed99a22201874f53c23fe5e4a58b"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , std::size_t Extent&gt; </td></tr>
<tr class="memitem:ac688ed99a22201874f53c23fe5e4a58b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1span.html">span</a>&lt; const unsigned char,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ac688ed99a22201874f53c23fe5e4a58b">as_bytes</a> (<a class="el" href="classgul14_1_1span.html">span</a>&lt; ElementType, Extent &gt; s) noexcept</td></tr>
<tr class="memdesc:ac688ed99a22201874f53c23fe5e4a58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant view to the byte representation of the elements of a given span.  <a href="namespacegul14.html#ac688ed99a22201874f53c23fe5e4a58b">More...</a><br /></td></tr>
<tr class="separator:ac688ed99a22201874f53c23fe5e4a58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1340b6d439aaf69260ea2b7f3ea0ce3"><td class="memTemplParams" colspan="2">template&lt;class ElementType , size_t Extent, typename std::enable_if&lt;!std::is_const&lt; ElementType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:af1340b6d439aaf69260ea2b7f3ea0ce3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1span.html">span</a>&lt; unsigned char,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#af1340b6d439aaf69260ea2b7f3ea0ce3">as_writable_bytes</a> (<a class="el" href="classgul14_1_1span.html">span</a>&lt; ElementType, Extent &gt; s) noexcept</td></tr>
<tr class="memdesc:af1340b6d439aaf69260ea2b7f3ea0ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable view to the byte representation of the elements of a given span.  <a href="namespacegul14.html#af1340b6d439aaf69260ea2b7f3ea0ce3">More...</a><br /></td></tr>
<tr class="separator:af1340b6d439aaf69260ea2b7f3ea0ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c01eba4544c9744ed896594c12370"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename E , std::size_t S&gt; </td></tr>
<tr class="memitem:aa73c01eba4544c9744ed896594c12370"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa73c01eba4544c9744ed896594c12370">get</a> (<a class="el" href="classgul14_1_1span.html">span</a>&lt; E, S &gt; s) -&gt; decltype(s[N])</td></tr>
<tr class="memdesc:aa73c01eba4544c9744ed896594c12370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the Nth element of a given span.  <a href="namespacegul14.html#aa73c01eba4544c9744ed896594c12370">More...</a><br /></td></tr>
<tr class="separator:aa73c01eba4544c9744ed896594c12370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40910959ea2a39b4358547e620f33f13"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:a40910959ea2a39b4358547e620f33f13"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a> ()</td></tr>
<tr class="memdesc:a40910959ea2a39b4358547e620f33f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mock element accessor for containers.  <a href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">More...</a><br /></td></tr>
<tr class="separator:a40910959ea2a39b4358547e620f33f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b75f0d2f5432534ce5016f4f6133e2"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a06b75f0d2f5432534ce5016f4f6133e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2">mean</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:a06b75f0d2f5432534ce5016f4f6133e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the arithmetic mean value of all elements in a container.  <a href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2">More...</a><br /></td></tr>
<tr class="separator:a06b75f0d2f5432534ce5016f4f6133e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65eba81972f8d5fcf326d16f28eadb1"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad65eba81972f8d5fcf326d16f28eadb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ad65eba81972f8d5fcf326d16f28eadb1">rms</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ad65eba81972f8d5fcf326d16f28eadb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the root mean square of all elements in a container.  <a href="namespacegul14.html#ad65eba81972f8d5fcf326d16f28eadb1">More...</a><br /></td></tr>
<tr class="separator:ad65eba81972f8d5fcf326d16f28eadb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3754c8155dbab769a73179dc794b5258"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3754c8155dbab769a73179dc794b5258"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a3754c8155dbab769a73179dc794b5258">median</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:a3754c8155dbab769a73179dc794b5258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of all elements in a container.  <a href="namespacegul14.html#a3754c8155dbab769a73179dc794b5258">More...</a><br /></td></tr>
<tr class="separator:a3754c8155dbab769a73179dc794b5258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b824c80d48bff9d5ec5c42950dc279"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a78b824c80d48bff9d5ec5c42950dc279"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279">maximum</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:a78b824c80d48bff9d5ec5c42950dc279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum element value in a container.  <a href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279">More...</a><br /></td></tr>
<tr class="separator:a78b824c80d48bff9d5ec5c42950dc279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0eef398fee8267047205743a451da6"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a5b0eef398fee8267047205743a451da6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6">minimum</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:a5b0eef398fee8267047205743a451da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum element value in a container.  <a href="namespacegul14.html#a5b0eef398fee8267047205743a451da6">More...</a><br /></td></tr>
<tr class="separator:a5b0eef398fee8267047205743a451da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34990e623ef0dacabedd01defd200599"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a34990e623ef0dacabedd01defd200599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a34990e623ef0dacabedd01defd200599">min_max</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="structgul14_1_1MinMax.html">MinMax</a>&lt; DataT &gt;</td></tr>
<tr class="memdesc:a34990e623ef0dacabedd01defd200599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum element values in a container.  <a href="namespacegul14.html#a34990e623ef0dacabedd01defd200599">More...</a><br /></td></tr>
<tr class="separator:a34990e623ef0dacabedd01defd200599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd9a11052c0ce4d3715cb4a405026d3"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acfd9a11052c0ce4d3715cb4a405026d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#acfd9a11052c0ce4d3715cb4a405026d3">remove_outliers</a> (ContainerT &amp;&amp;cont, std::size_t outliers, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ContainerT &amp;</td></tr>
<tr class="memdesc:acfd9a11052c0ce4d3715cb4a405026d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements that are far away from other elements.  <a href="namespacegul14.html#acfd9a11052c0ce4d3715cb4a405026d3">More...</a><br /></td></tr>
<tr class="separator:acfd9a11052c0ce4d3715cb4a405026d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c8faba2570251d314f445455e7f4a2"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a71c8faba2570251d314f445455e7f4a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a71c8faba2570251d314f445455e7f4a2">remove_outliers</a> (ContainerT const &amp;cont, std::size_t outliers, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; std::vector&lt; ElementT &gt;</td></tr>
<tr class="memdesc:a71c8faba2570251d314f445455e7f4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified.  <a href="namespacegul14.html#a71c8faba2570251d314f445455e7f4a2">More...</a><br /></td></tr>
<tr class="separator:a71c8faba2570251d314f445455e7f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bfa0fde0d5eb6c3367f1d55f2504b1"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a56bfa0fde0d5eb6c3367f1d55f2504b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">standard_deviation</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="classgul14_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt; ResultT &gt;</td></tr>
<tr class="memdesc:a56bfa0fde0d5eb6c3367f1d55f2504b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the standard deviation of all elements in a container.  <a href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">More...</a><br /></td></tr>
<tr class="separator:a56bfa0fde0d5eb6c3367f1d55f2504b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3c19683bdfc90cfadc1c758b1892d0"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure , typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2f3c19683bdfc90cfadc1c758b1892d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a2f3c19683bdfc90cfadc1c758b1892d0">accumulate</a> (ContainerT const &amp;container, OpClosure op, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:a2f3c19683bdfc90cfadc1c758b1892d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate some aggregate value from all elements of a container.  <a href="namespacegul14.html#a2f3c19683bdfc90cfadc1c758b1892d0">More...</a><br /></td></tr>
<tr class="separator:a2f3c19683bdfc90cfadc1c758b1892d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b40114e8bab88bb79c0e0b1120e9e5"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:a07b40114e8bab88bb79c0e0b1120e9e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a07b40114e8bab88bb79c0e0b1120e9e5">mean</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:a07b40114e8bab88bb79c0e0b1120e9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#a07b40114e8bab88bb79c0e0b1120e9e5">More...</a><br /></td></tr>
<tr class="separator:a07b40114e8bab88bb79c0e0b1120e9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf56fb354125c39033dbd092b6da35fb"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:abf56fb354125c39033dbd092b6da35fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#abf56fb354125c39033dbd092b6da35fb">rms</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:abf56fb354125c39033dbd092b6da35fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#abf56fb354125c39033dbd092b6da35fb">More...</a><br /></td></tr>
<tr class="separator:abf56fb354125c39033dbd092b6da35fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae315105546e683a5660d30b3eafef51a"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae315105546e683a5660d30b3eafef51a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ae315105546e683a5660d30b3eafef51a">median</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ae315105546e683a5660d30b3eafef51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#ae315105546e683a5660d30b3eafef51a">More...</a><br /></td></tr>
<tr class="separator:ae315105546e683a5660d30b3eafef51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7ed06f5c069bf60497a952cdd21724"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:a5b7ed06f5c069bf60497a952cdd21724"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a5b7ed06f5c069bf60497a952cdd21724">maximum</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:a5b7ed06f5c069bf60497a952cdd21724"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#a5b7ed06f5c069bf60497a952cdd21724">More...</a><br /></td></tr>
<tr class="separator:a5b7ed06f5c069bf60497a952cdd21724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c54558fdb27f24eb6b1289da65f9ea"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac0c54558fdb27f24eb6b1289da65f9ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ac0c54558fdb27f24eb6b1289da65f9ea">minimum</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ac0c54558fdb27f24eb6b1289da65f9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#ac0c54558fdb27f24eb6b1289da65f9ea">More...</a><br /></td></tr>
<tr class="separator:ac0c54558fdb27f24eb6b1289da65f9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b39ec77e4f4f4e773a93313d36f5da8"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6b39ec77e4f4f4e773a93313d36f5da8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a6b39ec77e4f4f4e773a93313d36f5da8">min_max</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="structgul14_1_1MinMax.html">MinMax</a>&lt; DataT &gt;</td></tr>
<tr class="memdesc:a6b39ec77e4f4f4e773a93313d36f5da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#a6b39ec77e4f4f4e773a93313d36f5da8">More...</a><br /></td></tr>
<tr class="separator:a6b39ec77e4f4f4e773a93313d36f5da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401025215ceed0e841b6f5339aecea98"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:a401025215ceed0e841b6f5339aecea98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a401025215ceed0e841b6f5339aecea98">remove_outliers</a> (IteratorT const &amp;begin, IteratorT const &amp;end, std::size_t outliers, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; std::vector&lt; ElementT &gt;</td></tr>
<tr class="memdesc:a401025215ceed0e841b6f5339aecea98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified.  <a href="namespacegul14.html#a401025215ceed0e841b6f5339aecea98">More...</a><br /></td></tr>
<tr class="separator:a401025215ceed0e841b6f5339aecea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7733f5947169eb1fcf6d5d56f05a5dde"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7733f5947169eb1fcf6d5d56f05a5dde"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a7733f5947169eb1fcf6d5d56f05a5dde">standard_deviation</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="classgul14_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt; ResultT &gt;</td></tr>
<tr class="memdesc:a7733f5947169eb1fcf6d5d56f05a5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#a7733f5947169eb1fcf6d5d56f05a5dde">More...</a><br /></td></tr>
<tr class="separator:a7733f5947169eb1fcf6d5d56f05a5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccc162f651af3b868439e705aafae45"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure &gt; </td></tr>
<tr class="memitem:adccc162f651af3b868439e705aafae45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate</a> (IteratorT const &amp;begin, IteratorT const &amp;end, OpClosure op, Accessor accessor=<a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:adccc162f651af3b868439e705aafae45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="namespacegul14.html#adccc162f651af3b868439e705aafae45">More...</a><br /></td></tr>
<tr class="separator:adccc162f651af3b868439e705aafae45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaca240c1cd99e9a477f8c2eb8b8880"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral&lt; Integer &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:adbaca240c1cd99e9a477f8c2eb8b8880"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a> (Integer v)</td></tr>
<tr class="memdesc:adbaca240c1cd99e9a477f8c2eb8b8880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of an integer value.  <a href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">More...</a><br /></td></tr>
<tr class="separator:adbaca240c1cd99e9a477f8c2eb8b8880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73e60faf7662dcdaf7672e1302200f3"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:af73e60faf7662dcdaf7672e1302200f3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#af73e60faf7662dcdaf7672e1302200f3">hex_string</a> (Iterator begin, Iterator end, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> separator=&quot;&quot;)</td></tr>
<tr class="memdesc:af73e60faf7662dcdaf7672e1302200f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of a range of integer values.  <a href="namespacegul14.html#af73e60faf7662dcdaf7672e1302200f3">More...</a><br /></td></tr>
<tr class="separator:af73e60faf7662dcdaf7672e1302200f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52554b24668d3d37657197b2b7fe0dc"><td class="memTemplParams" colspan="2">template&lt;typename Integer , size_t num_elements, std::enable_if_t&lt; std::is_integral&lt; Integer &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:aa52554b24668d3d37657197b2b7fe0dc"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa52554b24668d3d37657197b2b7fe0dc">hex_string</a> (const Integer(&amp;array)[num_elements], <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> separator=&quot;&quot;)</td></tr>
<tr class="memdesc:aa52554b24668d3d37657197b2b7fe0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of an array with integer values.  <a href="namespacegul14.html#aa52554b24668d3d37657197b2b7fe0dc">More...</a><br /></td></tr>
<tr class="separator:aa52554b24668d3d37657197b2b7fe0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25afcbd157fb5ea3b532097d4226cfab"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; IsContainerLike&lt; Container &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a25afcbd157fb5ea3b532097d4226cfab"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a25afcbd157fb5ea3b532097d4226cfab">hex_string</a> (const Container &amp;container, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> separator=&quot;&quot;)</td></tr>
<tr class="memdesc:a25afcbd157fb5ea3b532097d4226cfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of a container with integer values.  <a href="namespacegul14.html#a25afcbd157fb5ea3b532097d4226cfab">More...</a><br /></td></tr>
<tr class="separator:a25afcbd157fb5ea3b532097d4226cfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05731d015fe2827d95fffd6432ba74d"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">safe_string</a> (const char *char_ptr, std::size_t length)</td></tr>
<tr class="memdesc:af05731d015fe2827d95fffd6432ba74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely construct a std::string from a char pointer and a length.  <a href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">More...</a><br /></td></tr>
<tr class="separator:af05731d015fe2827d95fffd6432ba74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3b2164aa4cb31da1adbba96a552573"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573">contains</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> haystack, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> needle) noexcept</td></tr>
<tr class="memdesc:adc3b2164aa4cb31da1adbba96a552573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains another string.  <a href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573">More...</a><br /></td></tr>
<tr class="separator:adc3b2164aa4cb31da1adbba96a552573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18f368f80a6e3f46c6cb9958f2536c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a1f18f368f80a6e3f46c6cb9958f2536c">contains</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> haystack, char needle) noexcept</td></tr>
<tr class="memdesc:a1f18f368f80a6e3f46c6cb9958f2536c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains a certain character.  <a href="namespacegul14.html#a1f18f368f80a6e3f46c6cb9958f2536c">More...</a><br /></td></tr>
<tr class="separator:a1f18f368f80a6e3f46c6cb9958f2536c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c954601217f1c63884d1f9f767c338"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a25c954601217f1c63884d1f9f767c338">ends_with</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> suffix) noexcept</td></tr>
<tr class="memdesc:a25c954601217f1c63884d1f9f767c338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with another string.  <a href="namespacegul14.html#a25c954601217f1c63884d1f9f767c338">More...</a><br /></td></tr>
<tr class="separator:a25c954601217f1c63884d1f9f767c338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271d1a7a22f79576570f63e939eb191a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a271d1a7a22f79576570f63e939eb191a">ends_with</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, char c) noexcept</td></tr>
<tr class="memdesc:a271d1a7a22f79576570f63e939eb191a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with a certain character.  <a href="namespacegul14.html#a271d1a7a22f79576570f63e939eb191a">More...</a><br /></td></tr>
<tr class="separator:a271d1a7a22f79576570f63e939eb191a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85883e07b4ec2e653b4fb255f4f04b8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ad85883e07b4ec2e653b4fb255f4f04b8">starts_with</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> prefix) noexcept</td></tr>
<tr class="memdesc:ad85883e07b4ec2e653b4fb255f4f04b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with another string.  <a href="namespacegul14.html#ad85883e07b4ec2e653b4fb255f4f04b8">More...</a><br /></td></tr>
<tr class="separator:ad85883e07b4ec2e653b4fb255f4f04b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36e065917e667674d910c4a1bede51c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ae36e065917e667674d910c4a1bede51c">starts_with</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, char c) noexcept</td></tr>
<tr class="memdesc:ae36e065917e667674d910c4a1bede51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with a certain character.  <a href="namespacegul14.html#ae36e065917e667674d910c4a1bede51c">More...</a><br /></td></tr>
<tr class="separator:ae36e065917e667674d910c4a1bede51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05127f08f53568d1b4bd199137b76ab8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a05127f08f53568d1b4bd199137b76ab8">equals_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str1, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str2) noexcept</td></tr>
<tr class="memdesc:a05127f08f53568d1b4bd199137b76ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string is equal to another one, making no distinction between upper and lower case ASCII characters.  <a href="namespacegul14.html#a05127f08f53568d1b4bd199137b76ab8">More...</a><br /></td></tr>
<tr class="separator:a05127f08f53568d1b4bd199137b76ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913fd6012b85d8c0d4d51c0478c5164"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164">contains_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> haystack, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> needle) noexcept</td></tr>
<tr class="memdesc:a9913fd6012b85d8c0d4d51c0478c5164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains another string.  <a href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164">More...</a><br /></td></tr>
<tr class="separator:a9913fd6012b85d8c0d4d51c0478c5164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9cd4896149930f4b4eb9c127d2554"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ae4e9cd4896149930f4b4eb9c127d2554">contains_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> haystack, char needle) noexcept</td></tr>
<tr class="memdesc:ae4e9cd4896149930f4b4eb9c127d2554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains a certain character.  <a href="namespacegul14.html#ae4e9cd4896149930f4b4eb9c127d2554">More...</a><br /></td></tr>
<tr class="separator:ae4e9cd4896149930f4b4eb9c127d2554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad247f13c1c43036097c549f043c30fe"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe">ends_with_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> suffix) noexcept</td></tr>
<tr class="memdesc:aad247f13c1c43036097c549f043c30fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with another string.  <a href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe">More...</a><br /></td></tr>
<tr class="separator:aad247f13c1c43036097c549f043c30fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2591738dfca418424c6440f8762a8ba3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a2591738dfca418424c6440f8762a8ba3">ends_with_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, char c) noexcept</td></tr>
<tr class="memdesc:a2591738dfca418424c6440f8762a8ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with a certain character.  <a href="namespacegul14.html#a2591738dfca418424c6440f8762a8ba3">More...</a><br /></td></tr>
<tr class="separator:a2591738dfca418424c6440f8762a8ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b555f8e8d57d41abbc5f3b1d5480c19"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19">starts_with_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> prefix) noexcept</td></tr>
<tr class="memdesc:a9b555f8e8d57d41abbc5f3b1d5480c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with another string.  <a href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19">More...</a><br /></td></tr>
<tr class="separator:a9b555f8e8d57d41abbc5f3b1d5480c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5572dd02a7d92918dde5f75c18f559"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a1d5572dd02a7d92918dde5f75c18f559">starts_with_nocase</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, char c) noexcept</td></tr>
<tr class="memdesc:a1d5572dd02a7d92918dde5f75c18f559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with a certain character.  <a href="namespacegul14.html#a1d5572dd02a7d92918dde5f75c18f559">More...</a><br /></td></tr>
<tr class="separator:a1d5572dd02a7d92918dde5f75c18f559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af863dc04f4588482947e31f758762b89"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#af863dc04f4588482947e31f758762b89">tic</a> ()</td></tr>
<tr class="memdesc:af863dc04f4588482947e31f758762b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current time as a std::chrono time_point.  <a href="namespacegul14.html#af863dc04f4588482947e31f758762b89">More...</a><br /></td></tr>
<tr class="separator:af863dc04f4588482947e31f758762b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e46ff24705fce82ca32121620a54e"><td class="memTemplParams" colspan="2">template&lt;class TimeUnitType  = std::chrono::duration&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a093e46ff24705fce82ca32121620a54e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e">toc</a> (std::chrono::steady_clock::time_point t0)</td></tr>
<tr class="memdesc:a093e46ff24705fce82ca32121620a54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elapsed time in seconds (or a different unit) since the given time point.  <a href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e">More...</a><br /></td></tr>
<tr class="separator:a093e46ff24705fce82ca32121620a54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0abe7bf6452e6882c0e0b0d05897adc"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:aa0abe7bf6452e6882c0e0b0d05897adc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">sleep</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;duration, const <a class="el" href="classgul14_1_1Trigger.html">Trigger</a> &amp;trg)</td></tr>
<tr class="memdesc:aa0abe7bf6452e6882c0e0b0d05897adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given time span, with the option of being woken up from another thread.  <a href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">More...</a><br /></td></tr>
<tr class="separator:aa0abe7bf6452e6882c0e0b0d05897adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b3b3ee304683df1af8c8f921bc9d6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa7b3b3ee304683df1af8c8f921bc9d6b">sleep</a> (double seconds, const <a class="el" href="classgul14_1_1Trigger.html">Trigger</a> &amp;trg)</td></tr>
<tr class="memdesc:aa7b3b3ee304683df1af8c8f921bc9d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given number of seconds, with the option of being woken up from another thread.  <a href="namespacegul14.html#aa7b3b3ee304683df1af8c8f921bc9d6b">More...</a><br /></td></tr>
<tr class="separator:aa7b3b3ee304683df1af8c8f921bc9d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac510f7b538a9b9eab94b885e60703214"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:ac510f7b538a9b9eab94b885e60703214"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#ac510f7b538a9b9eab94b885e60703214">sleep</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;duration)</td></tr>
<tr class="memdesc:ac510f7b538a9b9eab94b885e60703214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given time span.  <a href="namespacegul14.html#ac510f7b538a9b9eab94b885e60703214">More...</a><br /></td></tr>
<tr class="separator:ac510f7b538a9b9eab94b885e60703214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbed53d6d2a8cef5208d06fa6e67cbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a7bbed53d6d2a8cef5208d06fa6e67cbf">sleep</a> (double seconds)</td></tr>
<tr class="memdesc:a7bbed53d6d2a8cef5208d06fa6e67cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given number of seconds.  <a href="namespacegul14.html#a7bbed53d6d2a8cef5208d06fa6e67cbf">More...</a><br /></td></tr>
<tr class="separator:a7bbed53d6d2a8cef5208d06fa6e67cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b503aeb7d32d9e9582d4115975c72f7"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , std::enable_if_t&lt; std::is_integral&lt; NumberType &gt;::value &amp;&amp;std::is_unsigned&lt; NumberType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1b503aeb7d32d9e9582d4115975c72f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1optional.html">optional</a>&lt; NumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a1b503aeb7d32d9e9582d4115975c72f7">to_number</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a> str) noexcept</td></tr>
<tr class="memdesc:a1b503aeb7d32d9e9582d4115975c72f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an ASCII string_view into a number.  <a href="namespacegul14.html#a1b503aeb7d32d9e9582d4115975c72f7">More...</a><br /></td></tr>
<tr class="separator:a1b503aeb7d32d9e9582d4115975c72f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e8600a02fd663c746353934b0e224c"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </td></tr>
<tr class="memitem:aa8e8600a02fd663c746353934b0e224c"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c">tokenize</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> delimiters=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:aa8e8600a02fd663c746353934b0e224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string into a vector of substrings (tokens) delimited by any of the characters in the delimiters string.  <a href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c">More...</a><br /></td></tr>
<tr class="separator:aa8e8600a02fd663c746353934b0e224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d994c05e195f77821b1253b8aaf36"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;string_view&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </td></tr>
<tr class="memitem:a419d994c05e195f77821b1253b8aaf36"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a419d994c05e195f77821b1253b8aaf36">tokenize_sv</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> delimiters=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:a419d994c05e195f77821b1253b8aaf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string into a vector of substrings (tokens) delimited by any of the characters in the delimiters string.  <a href="namespacegul14.html#a419d994c05e195f77821b1253b8aaf36">More...</a><br /></td></tr>
<tr class="separator:a419d994c05e195f77821b1253b8aaf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af285e7ea3b0a077734c00e2059f330"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330">trim</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> ws_chars=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:a0af285e7ea3b0a077734c00e2059f330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and trailing whitespace (or a custom set of characters) from a string, returning a new std::string.  <a href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330">More...</a><br /></td></tr>
<tr class="separator:a0af285e7ea3b0a077734c00e2059f330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4755d57b125523fefbadf2b4f6773e"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e">trim_sv</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> ws_chars=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:a8d4755d57b125523fefbadf2b4f6773e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and trailing whitespace (or a custom set of characters) from a string, returning a view into the original string.  <a href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e">More...</a><br /></td></tr>
<tr class="separator:a8d4755d57b125523fefbadf2b4f6773e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cfeb1eb167325b12ba86a65dc04f3e"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e">trim_left</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> ws_chars=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:a79cfeb1eb167325b12ba86a65dc04f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.  <a href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e">More...</a><br /></td></tr>
<tr class="separator:a79cfeb1eb167325b12ba86a65dc04f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa3db5afdef851e15185589aaacb16b"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b">trim_left_sv</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> ws_chars=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:afaa3db5afdef851e15185589aaacb16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading whitespace (or a custom set of characters) from a string, returning a view into the original string.  <a href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b">More...</a><br /></td></tr>
<tr class="separator:afaa3db5afdef851e15185589aaacb16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75ce67592c33fda6f431085747b21cb"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb">trim_right</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> ws_chars=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:af75ce67592c33fda6f431085747b21cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.  <a href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb">More...</a><br /></td></tr>
<tr class="separator:af75ce67592c33fda6f431085747b21cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba61a104b118243c81a51eb72309a1"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1">trim_right_sv</a> (<a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> str, <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> ws_chars=<a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:a3cba61a104b118243c81a51eb72309a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the original string.  <a href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1">More...</a><br /></td></tr>
<tr class="separator:a3cba61a104b118243c81a51eb72309a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af998808f424b8170657e47e0d2de0d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4af998808f424b8170657e47e0d2de0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a4af998808f424b8170657e47e0d2de0d">type_name</a> ()</td></tr>
<tr class="memdesc:a4af998808f424b8170657e47e0d2de0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a human readable string describing a type.  <a href="namespacegul14.html#a4af998808f424b8170657e47e0d2de0d">More...</a><br /></td></tr>
<tr class="separator:a4af998808f424b8170657e47e0d2de0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2dfe9f0d3222edbf1ddab35d9d452e4f"><td class="memItemLeft" align="right" valign="top">const GUL_EXPORT <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a> { &quot; \t\r\n\a\b\f\v&quot; }</td></tr>
<tr class="memdesc:a2dfe9f0d3222edbf1ddab35d9d452e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default characters that are treated as whitespace by GUL.  <a href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">More...</a><br /></td></tr>
<tr class="separator:a2dfe9f0d3222edbf1ddab35d9d452e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa061a14b864c17593e03fa540d3a51"><td class="memItemLeft" align="right" valign="top">const GUL_EXPORT std::array&lt; char, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a8fa061a14b864c17593e03fa540d3a51">hex_digits</a></td></tr>
<tr class="memdesc:a8fa061a14b864c17593e03fa540d3a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 16 digits for hexadecimal numbers ("0123456789abcdef").  <a href="namespacegul14.html#a8fa061a14b864c17593e03fa540d3a51">More...</a><br /></td></tr>
<tr class="separator:a8fa061a14b864c17593e03fa540d3a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695805a9a6f5eeeac8d13902d23d5dcf"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#a695805a9a6f5eeeac8d13902d23d5dcf">version_git</a></td></tr>
<tr class="memdesc:a695805a9a6f5eeeac8d13902d23d5dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the git version tag of the sources that the library has been build with.  <a href="namespacegul14.html#a695805a9a6f5eeeac8d13902d23d5dcf">More...</a><br /></td></tr>
<tr class="separator:a695805a9a6f5eeeac8d13902d23d5dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68ad44da881e2ae093a8ab80a1895c9"><td class="memItemLeft" align="right" valign="top"><a id="aa68ad44da881e2ae093a8ab80a1895c9"></a>
GUL_EXPORT char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul14.html#aa68ad44da881e2ae093a8ab80a1895c9">version_api</a></td></tr>
<tr class="memdesc:aa68ad44da881e2ae093a8ab80a1895c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the API version of the library. <br /></td></tr>
<tr class="separator:aa68ad44da881e2ae093a8ab80a1895c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afc1d6e2f0688dc334f92653ae1f7a5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1d6e2f0688dc334f92653ae1f7a5fa">&#9670;&nbsp;</a></span>BitFunctionReturnType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegul14.html#afc1d6e2f0688dc334f92653ae1f7a5fa">gul14::BitFunctionReturnType</a> = typedef std::enable_if_t&lt; std::is_integral&lt;T&gt;::value and not std::is_same&lt;std::decay_t&lt;T&gt;, bool&gt;::value, std::decay_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of the bit manipulation functions. </p>
<p>We want to SFINAE out of all types except integers. Because bools counts as integer type and we don't want that we specifically exclude it here.</p>
<p>The type is then simply the decayed input type, to get rid of const or volatile specifiers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type specified/deduced by bit_*() user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ebb24dac7ab090d9145ff49abab9013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebb24dac7ab090d9145ff49abab9013">&#9670;&nbsp;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a> = typedef <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A view to a contiguous sequence of chars. </p>
<p>This is a backport of <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::string_view</a> from libc++ for C++17. </p>

</div>
</div>
<a id="a95b2b4a816dea6586aea6e4e19dcf7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b2b4a816dea6586aea6e4e19dcf7a5">&#9670;&nbsp;</a></span>u16string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegul14.html#a95b2b4a816dea6586aea6e4e19dcf7a5">gul14::u16string_view</a> = typedef <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt;char16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A view to a contiguous sequence of char16_ts. </p>
<p>This is a backport of <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::string_view</a> from libc++ for C++17. </p>

</div>
</div>
<a id="a0414875154e5452182cfb76785d377bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0414875154e5452182cfb76785d377bc">&#9670;&nbsp;</a></span>u32string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegul14.html#a0414875154e5452182cfb76785d377bc">gul14::u32string_view</a> = typedef <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt;char32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A view to a contiguous sequence of char32_ts. </p>
<p>This is a backport of <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::string_view</a> from libc++ for C++17. </p>

</div>
</div>
<a id="a855c927b58e1d1854a727b815e8ce1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855c927b58e1d1854a727b815e8ce1c4">&#9670;&nbsp;</a></span>wstring_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegul14.html#a855c927b58e1d1854a727b815e8ce1c4">gul14::wstring_view</a> = typedef <a class="el" href="classgul14_1_1basic__string__view.html">basic_string_view</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A view to a contiguous sequence of wchar_ts. </p>
<p>This is a backport of <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::string_view</a> from libc++ for C++17. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2a276f44539a7a7e2d88c872486e2ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a276f44539a7a7e2d88c872486e2ff9">&#9670;&nbsp;</a></span>ShrinkBehavior</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegul14.html#a2a276f44539a7a7e2d88c872486e2ff9">gul14::ShrinkBehavior</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine how a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> handles decreases of its size. </p>
<p>When the buffer's capacity decreases below the actual size some elements have to be dropped. The user can choose between two strategies:</p>
<ol type="1">
<li>Keep the elements with the lower indices (<b><code>ShrinkBehavior::keep_front_elements</code></b>)</li>
<li>Keep the elements with the higher indices (<b><code>ShrinkBehavior::keep_back_elements</code></b>)</li>
</ol>
<p>Usually the more recent data shall be preserved, while older data can be dropped.</p>
<ul>
<li>If <a class="el" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">SlidingBuffer::push_front()</a> has been used to fill the buffer the front elements should then be kept.</li>
<li>If <a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">SlidingBuffer::push_back()</a> was the fill method the back elements are usually better to keep.</li>
<li>If a mixture of <a class="el" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">SlidingBuffer::push_front()</a> and <a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">SlidingBuffer::push_back()</a> has been used this is hard to decide.</li>
</ul>
<p>The behavior is utilized by <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">SlidingBuffer::resize()</a>, <a class="el" href="classgul14_1_1SlidingBuffer.html#a5290ddbfe6ef4a30cf066c5ec2af937b" title="Resize the container (identical to resize()).">SlidingBuffer::reserve()</a>, <a class="el" href="classgul14_1_1SlidingBufferExposed.html#a1dfa7103f33839f968e7623ca624f0c8" title="Resize the container.">SlidingBufferExposed::resize()</a>, and <a class="el" href="classgul14_1_1SlidingBufferExposed.html#a2e987e41c6fd352a1385daffb6728820" title="Resize the container (identical to resize()).">SlidingBufferExposed::reserve()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a02e71867d1a27d723ee0c2a3bcd7761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e71867d1a27d723ee0c2a3bcd7761c">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gul14::abs </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;std::is_unsigned&lt;ValueT&gt;::value, ValueT&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of a number. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This function is almost equal to <a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c" title="Compute the absolute value of a number.">std::abs()</a> with the exception of unsigned integral types, which are returned unchanged and in their original type. This is especially useful in templates, where <a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c" title="Compute the absolute value of a number.">std::abs()</a> cannot be used for all arithmetic types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number whose absolute value should be determined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of n. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#acfd9a11052c0ce4d3715cb4a405026d3">remove_outliers()</a>, <a class="el" href="namespacegul14.html#a3a06029dccf60523519d5a22a71ac361">within_abs()</a>, <a class="el" href="namespacegul14.html#ac147ccba8179827a34b584d6a7d11ac9">within_orders()</a>, and <a class="el" href="namespacegul14.html#a6c7886cf179298ea422806b253f0bb0c">within_ulp()</a>.</p>

</div>
</div>
<a id="a2f3c19683bdfc90cfadc1c758b1892d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3c19683bdfc90cfadc1c758b1892d0">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure , typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::accumulate </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpClosure&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate some aggregate value from all elements of a container. </p>
<p>This is similar to std::accumulate, but</p><ul>
<li>works on a whole container,</li>
<li>accesses the container elements through an accessor function,</li>
<li>applies the binary operator <code>op</code> to a running sum and each element value,</li>
<li>the sum's type is in the first template parameter, and</li>
<li>the initial value of the sum is its default constructed value.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">op</td><td>Binary operator to aggregate two values into one value </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the aggregate value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value / accumulator </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">accumulate(IteratorT const&amp;, IteratorT const&amp;, OpClosure, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="adccc162f651af3b868439e705aafae45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccc162f651af3b868439e705aafae45">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::accumulate </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpClosure&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">op</td><td>Binary operator to aggregate two values into one value </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a2f3c19683bdfc90cfadc1c758b1892d0" title="Calculate some aggregate value from all elements of a container.">accumulate(ContainerT const&amp;, OpClosure, Accessor)</a> accepts a container instead of iterators. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a2f3c19683bdfc90cfadc1c758b1892d0">accumulate()</a>, <a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279">maximum()</a>, <a class="el" href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2">mean()</a>, <a class="el" href="namespacegul14.html#a34990e623ef0dacabedd01defd200599">min_max()</a>, <a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6">minimum()</a>, <a class="el" href="namespacegul14.html#ad65eba81972f8d5fcf326d16f28eadb1">rms()</a>, and <a class="el" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">standard_deviation()</a>.</p>

</div>
</div>
<a id="ac688ed99a22201874f53c23fe5e4a58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac688ed99a22201874f53c23fe5e4a58b">&#9670;&nbsp;</a></span>as_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , std::size_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1span.html">span</a>&lt;const unsigned char, ((Extent == dynamic_extent) ? dynamic_extent : sizeof(ElementType) * Extent)&gt; gul14::as_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1span.html">span</a>&lt; ElementType, Extent &gt;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a constant view to the byte representation of the elements of a given span. </p>
<p>This is a backport from the C++20 standard library, see: <a href="https://en.cppreference.com/w/cpp/container/span/as_bytes">https://en.cppreference.com/w/cpp/container/span/as_bytes</a></p>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.9 </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1span.html#ac2b615d5b2ee8c05a1181e35a94ffe61">gul14::span&lt; ElementType, Extent &gt;::data()</a>, and <a class="el" href="classgul14_1_1span.html#ae156b16b27b66189c4295544a3c1f663">gul14::span&lt; ElementType, Extent &gt;::size_bytes()</a>.</p>

</div>
</div>
<a id="af1340b6d439aaf69260ea2b7f3ea0ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1340b6d439aaf69260ea2b7f3ea0ce3">&#9670;&nbsp;</a></span>as_writable_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t Extent, typename std::enable_if&lt;!std::is_const&lt; ElementType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1span.html">span</a>&lt;unsigned char, ((Extent == dynamic_extent) ? dynamic_extent : sizeof(ElementType) * Extent)&gt; gul14::as_writable_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1span.html">span</a>&lt; ElementType, Extent &gt;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable view to the byte representation of the elements of a given span. </p>
<p>This is a backport from the C++20 standard library, see: <a href="https://en.cppreference.com/w/cpp/container/span/as_bytes">https://en.cppreference.com/w/cpp/container/span/as_bytes</a></p>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.9 </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1span.html#ac2b615d5b2ee8c05a1181e35a94ffe61">gul14::span&lt; ElementType, Extent &gt;::data()</a>, and <a class="el" href="classgul14_1_1span.html#ae156b16b27b66189c4295544a3c1f663">gul14::span&lt; ElementType, Extent &gt;::size_bytes()</a>.</p>

</div>
</div>
<a id="a6b584ad55786999bbb6f822345d7cfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b584ad55786999bbb6f822345d7cfef">&#9670;&nbsp;</a></span>bit_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gul14::bit_flip </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ReturnT </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip a bit in an integral value. </p>
<p>Flips the bit number <b>bit</b> in the existing value <b>previous</b>. This inverts the state of the bit: setting the bit if it was previously not set and resetting the bit if it was previously set.</p>
<p>When <b>bit</b> is greater or equal to the number of bits in type <b>T</b>, std::abort() is called (via assert()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous</td><td>Existing integral value where the bit shall be modified </td></tr>
    <tr><td class="paramname">bit</td><td>Number of the bit that is to be modified (LSB == 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New integral value with the bit modified.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the bit-holding integral value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.8</dd></dl>
<dl class="section see"><dt>See also</dt><dd>bit_set(bit), bit_set(previous, bit), bit_reset(previous, bit), bit_test(bits, bit) </dd></dl>

</div>
</div>
<a id="aad702fe0f272a70a4da6f63de30bd295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad702fe0f272a70a4da6f63de30bd295">&#9670;&nbsp;</a></span>bit_reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gul14::bit_reset </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ReturnT </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset a bit in an integral value. </p>
<p>Reset (clear) the bit number <b>bit</b> in the existing value <b>previous</b>.</p>
<p>When <b>bit</b> is greater or equal to the number of bits in type <b>T</b>, std::abort() is called (via assert()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous</td><td>Existing integral value where the bit shall be modified </td></tr>
    <tr><td class="paramname">bit</td><td>Number of the bit that is to be modified (LSB == 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New integral value with the bit modified.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the bit-holding integral value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.8</dd></dl>
<dl class="section see"><dt>See also</dt><dd>bit_set(bit), bit_set(previous, bit), bit_flip(previous, bit), bit_test(bits, bit) </dd></dl>

</div>
</div>
<a id="acf64b788578bb3caa75680663677de9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf64b788578bb3caa75680663677de9a">&#9670;&nbsp;</a></span>bit_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gul14::bit_set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ReturnT </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a bit in an integral value. </p>
<p>Set the bit number <b>bit</b> in the existing value <b>previous</b>.</p>
<p>When <b>bit</b> is greater or equal to the number of bits in type <b>T</b>, std::abort() is called (via assert()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous</td><td>Existing integral value where the bit shall be modified </td></tr>
    <tr><td class="paramname">bit</td><td>Number of the bit that is to be modified (LSB == 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New integral value with the bit modified.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the bit-holding integral value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.8</dd></dl>
<dl class="section see"><dt>See also</dt><dd>bit_set(bit), bit_reset(previous, bit), bit_flip(previous, bit), bit_test(bits, bit) </dd></dl>

</div>
</div>
<a id="a65b66729b7fb79ec00fcff24eb3fcf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b66729b7fb79ec00fcff24eb3fcf13">&#9670;&nbsp;</a></span>bit_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = unsigned, typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gul14::bit_set </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td> -&gt; ReturnT </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a bit in an integral type. </p>
<p>Return an integral value of type <b>T</b> where the bit number <b>bit</b> and only that bit is set.</p>
<p>When <b>bit</b> is greater or equal to the number of bits in type <b>T</b>, std::abort() is called (via assert()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit</td><td>Number of the bit that is to be set (LSB == 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral value with the bit set.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the bit-holding integral value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no type <b>T</b> is specified an unsigned int will be returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.8</dd></dl>
<dl class="section see"><dt>See also</dt><dd>bit_set(previous, bit), bit_reset(previous, bit), bit_flip(previous, bit), bit_test(bits, bit) </dd></dl>

</div>
</div>
<a id="a908d23e591803cc8c98d63ba04ff0f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908d23e591803cc8c98d63ba04ff0f1a">&#9670;&nbsp;</a></span>bit_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::bit_test </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test a bit in an integral value. </p>
<p>Test the bit number <b>bit</b> in the existing value <b>bits</b>.</p>
<p>When <b>bit</b> is greater or equal to the number of bits in type <b>T</b>, std::abort() is called (via assert()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>Integral value where the bit shall be tested </td></tr>
    <tr><td class="paramname">bit</td><td>Number of the bit that is to be modified (LSB == 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the bit-holding integral value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.8</dd></dl>
<dl class="section see"><dt>See also</dt><dd>bit_set(bit), bit_set(previous, bit), bit_reset(previous, bit), bit_flip(previous, bit) </dd></dl>

</div>
</div>
<a id="ad64e01233c1c469a698c36c9e2f89079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64e01233c1c469a698c36c9e2f89079">&#9670;&nbsp;</a></span>cat() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::cat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently concatenate an arbitrary number of strings and numbers. </p>
<p>Numbers are converted to strings in the same way as done by std::to_string. <a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079" title="Efficiently concatenate an arbitrary number of strings and numbers.">cat()</a> reserves the correct amount of space before concatenating the strings and can therefore save several memory allocations compared to concatenation with "+". </p><div class="fragment"><div class="line">std::string str = <a class="code" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079">gul14::cat</a>(13.5, std::string(<span class="stringliteral">&quot; quick &quot;</span>), <span class="stringliteral">&quot;brown foxes &quot;</span>, <span class="stringliteral">&quot;jump over &quot;</span>,</div>
<div class="line">                           42, <span class="stringliteral">&quot; lazy dogs&#39;&quot;</span>, std::string(<span class="stringliteral">&quot; heads.&quot;</span>));</div>
<div class="line"><span class="comment">// str == &quot;13.500000 quick brown foxes jump over 42 lazy dogs&#39; heads.&quot;</span></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>a string containing the concatenation of all arguments. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">gul14::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt;::at()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a4ca0b25404a79967d68fff9dbe1b9207">gul14::SmallVector&lt; ElementT, in_capacity &gt;::at()</a>, and <a class="el" href="namespacegul14.html#a8f160d726ecd0581d66e87d34250f3dd">cat()</a>.</p>

</div>
</div>
<a id="a8f160d726ecd0581d66e87d34250f3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f160d726ecd0581d66e87d34250f3dd">&#9670;&nbsp;</a></span>cat() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename  = std::enable_if_t&lt;(sizeof...(Args) &gt; 3)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::cat </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079" title="Efficiently concatenate an arbitrary number of strings and numbers.">cat()</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079">cat()</a>.</p>

</div>
</div>
<a id="aa9c7a3d661fe67ea5caf4911298c890e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c7a3d661fe67ea5caf4911298c890e">&#9670;&nbsp;</a></span>cat() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079" title="Efficiently concatenate an arbitrary number of strings and numbers.">cat()</a> </dd></dl>

</div>
</div>
<a id="aaac1958ae0fa576e1135a5f30ce7c3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac1958ae0fa576e1135a5f30ce7c3e2">&#9670;&nbsp;</a></span>cat() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079" title="Efficiently concatenate an arbitrary number of strings and numbers.">cat()</a> </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1ConvertingStringView.html#a01971d49d7b61d4cf350ee1aca796dea">gul14::ConvertingStringView::data()</a>, and <a class="el" href="classgul14_1_1ConvertingStringView.html#ac00946a9c1f8e30cdec354bdb5dae89f">gul14::ConvertingStringView::length()</a>.</p>

</div>
</div>
<a id="a619aa48a0c092249f1cfd5e853526783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619aa48a0c092249f1cfd5e853526783">&#9670;&nbsp;</a></span>cat() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::cat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;&#160;</td>
          <td class="paramname"><em>s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079" title="Efficiently concatenate an arbitrary number of strings and numbers.">cat()</a> </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1ConvertingStringView.html#a01971d49d7b61d4cf350ee1aca796dea">gul14::ConvertingStringView::data()</a>, and <a class="el" href="classgul14_1_1ConvertingStringView.html#ac00946a9c1f8e30cdec354bdb5dae89f">gul14::ConvertingStringView::length()</a>.</p>

</div>
</div>
<a id="afbb6e8fb55a42007d2febd6cd7ae8d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb6e8fb55a42007d2febd6cd7ae8d7a">&#9670;&nbsp;</a></span>cat() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::cat </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classgul14_1_1ConvertingStringView.html">ConvertingStringView</a> &gt;&#160;</td>
          <td class="paramname"><em>pieces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079" title="Efficiently concatenate an arbitrary number of strings and numbers.">cat()</a> </dd></dl>

</div>
</div>
<a id="ac1b5967a0b377c9d4b3791db8e2e20a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b5967a0b377c9d4b3791db8e2e20a3">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const NumT&amp; gul14::clamp </td>
          <td>(</td>
          <td class="paramtype">const NumT &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumT &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumT &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coerce a value to be within a given range. </p>
<p>Check if value <code>v</code> is between (including) <code>lo</code> and <code>hi</code>. If it is too low, <code>lo</code> is returned. If it is too high, <code>hi</code> is returned.</p>
<p><code>lo</code> must not be greater than <code>hi</code>, but they are allowed to be equal.</p>
<p>Only <code>operator&lt;()</code> is used for this, so it has to be defined for <code>NumT</code>.</p>
<p>Note that all parameters need to be of the same type. Add the correct suffix if using a literal as shown in the following example: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> c = ...;</div>
<div class="line"><span class="keywordtype">size_t</span> s = ...;</div>
<div class="line"><span class="keywordtype">float</span> f = ...;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> c2 = <a class="code" href="namespacegul14.html#ac1b5967a0b377c9d4b3791db8e2e20a3">clamp</a>(c, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;z&#39;</span>);</div>
<div class="line"><span class="keyword">auto</span> s2 = <a class="code" href="namespacegul14.html#ac1b5967a0b377c9d4b3791db8e2e20a3">clamp</a>(s, 0ul, 1000ul);</div>
<div class="line"><span class="keyword">auto</span> f2 = <a class="code" href="namespacegul14.html#ac1b5967a0b377c9d4b3791db8e2e20a3">clamp</a>(f, 0.0f, 99.0f);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumT</td><td>Type of the objects to compare. Needs to have <code>operator&lt;()</code> defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to clamp </td></tr>
    <tr><td class="paramname">lo</td><td>The lower boundary to clamp <code>v</code> to </td></tr>
    <tr><td class="paramname">hi</td><td>The upper boundary to clamp <code>v</code> to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>lo</code> if <code>v</code> is less than <code>lo</code>, a reference to <code>hi</code> if <code>hi</code> is less than <code>v</code>, or a reference to <code>v</code> otherwise. </dd></dl>

</div>
</div>
<a id="aee09fca8383e6c5b1b172cf3e0740273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee09fca8383e6c5b1b172cf3e0740273">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumT , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const NumT&amp; gul14::clamp </td>
          <td>(</td>
          <td class="paramtype">const NumT &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumT &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumT &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumT</td><td>Type of the objects to compare. Needs to have <code>operator&lt;()</code> defined. </td></tr>
    <tr><td class="paramname">Compare</td><td>Type of the comparison function. See notes below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to clamp </td></tr>
    <tr><td class="paramname">lo</td><td>The lower boundary to clamp <code>v</code> to </td></tr>
    <tr><td class="paramname">hi</td><td>The upper boundary to clamp <code>v</code> to </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison function object which returns true if the first argument is less than the second.</td></tr>
  </table>
  </dd>
</dl>
<p>The signature of the comparison function should be equivalent to the following: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> cmp(<span class="keyword">const</span> Type1&amp; a, <span class="keyword">const</span> Type2&amp; b);</div>
</div><!-- fragment --><p> While the signature does not explicitly require passing the arguments by const reference, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) <code>Type1</code> and <code>Type2</code> regardless of value category. This means that neither <code>Type1 &amp;</code> nor <code>Type1</code> are allowed unless a move is equivalent to a copy for <code>Type1</code>. The types <code>Type1</code> and <code>Type2</code> must be such that an object of type <code>T</code> can be implicitly converted to both of them. </p>

</div>
</div>
<a id="a1f18f368f80a6e3f46c6cb9958f2536c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18f368f80a6e3f46c6cb9958f2536c">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string contains a certain character. </p>
<p>The comparison is case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string in which to search. </td></tr>
    <tr><td class="paramname">needle</td><td>The character that should be searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>haystack</code> contains at least one occurrence of <code>needle</code>, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573" title="Determine whether a string contains another string.">contains(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#ae4e9cd4896149930f4b4eb9c127d2554" title="Determine whether a string contains a certain character.">contains_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#a271d1a7a22f79576570f63e939eb191a" title="Determine whether a string ends with a certain character.">ends_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#ae36e065917e667674d910c4a1bede51c" title="Determine whether a string starts with a certain character.">starts_with(string_view, char)</a> </dd></dl>

</div>
</div>
<a id="adc3b2164aa4cb31da1adbba96a552573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3b2164aa4cb31da1adbba96a552573">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string contains another string. </p>
<p>The comparison is case sensitive. If the searched-for string is empty, the result is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string in which to search. </td></tr>
    <tr><td class="paramname">needle</td><td>The string that should be searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>haystack</code> contains at least one occurrence of <code>needle</code>, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a1f18f368f80a6e3f46c6cb9958f2536c" title="Determine whether a string contains a certain character.">contains(string_view, char)</a>, <a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164" title="Determine whether a string contains another string.">contains_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a25c954601217f1c63884d1f9f767c338" title="Determine whether a string ends with another string.">ends_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#ad85883e07b4ec2e653b4fb255f4f04b8" title="Determine whether a string starts with another string.">starts_with(string_view, string_view)</a> </dd></dl>

</div>
</div>
<a id="ae4e9cd4896149930f4b4eb9c127d2554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e9cd4896149930f4b4eb9c127d2554">&#9670;&nbsp;</a></span>contains_nocase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::contains_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string contains a certain character. </p>
<p>The comparison is case insensitive as far as ASCII characters are concerned (C locale).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string in which to search. </td></tr>
    <tr><td class="paramname">needle</td><td>The character that should be searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>haystack</code> contains at least one occurrence of <code>needle</code>, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164" title="Determine whether a string contains another string.">contains_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a1f18f368f80a6e3f46c6cb9958f2536c" title="Determine whether a string contains a certain character.">contains(string_view, char)</a>, <a class="el" href="namespacegul14.html#a2591738dfca418424c6440f8762a8ba3" title="Determine whether a string ends with a certain character.">ends_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#a1d5572dd02a7d92918dde5f75c18f559" title="Determine whether a string starts with a certain character.">starts_with_nocase(string_view, char)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a9913fd6012b85d8c0d4d51c0478c5164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913fd6012b85d8c0d4d51c0478c5164">&#9670;&nbsp;</a></span>contains_nocase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::contains_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string contains another string. </p>
<p>The comparison is case insensitive as far as ASCII characters are concerned (C locale). If the searched-for string is empty, the result is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string in which to search. </td></tr>
    <tr><td class="paramname">needle</td><td>The string that should be searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>haystack</code> contains at least one occurrence of <code>needle</code>, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not allocate memory to buffer the case-transformed input strings. It might therefore have lower performance than combining <a class="el" href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573" title="Determine whether a string contains another string.">contains()</a> and <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052" title="Return the ASCII lowercase equivalent of the given character (or the unchanged character,...">lowercase_ascii()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ae4e9cd4896149930f4b4eb9c127d2554" title="Determine whether a string contains a certain character.">contains_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573" title="Determine whether a string contains another string.">contains(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe" title="Determine whether a string ends with another string.">ends_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19" title="Determine whether a string starts with another string.">starts_with_nocase(string_view, string_view)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a40910959ea2a39b4358547e620f33f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40910959ea2a39b4358547e620f33f13">&#9670;&nbsp;</a></span>ElementAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::ElementAccessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mock element accessor for containers. </p>
<p>All functions in <a class="el" href="statistics_8h.html" title="Declaration of statistical utility functions and classes for the General Utility Library.">statistics.h</a> access the elements of the containers they work on through accessor functions. If the container is simple, i.e. contains just the types we want to work on (like double of std::vector&lt;double&gt;) we can automate the generation of the accessor function, so that the user does not need to specify it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>Type of the elements in the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to accessor function </dd></dl>

</div>
</div>
<a id="a271d1a7a22f79576570f63e939eb191a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271d1a7a22f79576570f63e939eb191a">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string ends with a certain character. </p>
<p>The comparison is case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be tested. </td></tr>
    <tr><td class="paramname">c</td><td>The character to be looked for at the end of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> ends with <code>c</code>, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a25c954601217f1c63884d1f9f767c338" title="Determine whether a string ends with another string.">ends_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a2591738dfca418424c6440f8762a8ba3" title="Determine whether a string ends with a certain character.">ends_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#ae36e065917e667674d910c4a1bede51c" title="Determine whether a string starts with a certain character.">starts_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#a1f18f368f80a6e3f46c6cb9958f2536c" title="Determine whether a string contains a certain character.">contains(string_view, char)</a> </dd></dl>

</div>
</div>
<a id="a25c954601217f1c63884d1f9f767c338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c954601217f1c63884d1f9f767c338">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string ends with another string. </p>
<p>The comparison is case sensitive. If the searched-for suffix is empty, the result is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The full string to be tested. </td></tr>
    <tr><td class="paramname">suffix</td><td>The suffix to be looked for at the end of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> ends with <code>suffix</code>, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a271d1a7a22f79576570f63e939eb191a" title="Determine whether a string ends with a certain character.">ends_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe" title="Determine whether a string ends with another string.">ends_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#ad85883e07b4ec2e653b4fb255f4f04b8" title="Determine whether a string starts with another string.">starts_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573" title="Determine whether a string contains another string.">contains(string_view, string_view)</a> </dd></dl>

</div>
</div>
<a id="a2591738dfca418424c6440f8762a8ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2591738dfca418424c6440f8762a8ba3">&#9670;&nbsp;</a></span>ends_with_nocase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::ends_with_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string ends with a certain character. </p>
<p>The comparison is case insensitive as far as ASCII characters are concerned (C locale).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be tested. </td></tr>
    <tr><td class="paramname">c</td><td>The character to be looked for at the end of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> ends with <code>c</code>, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe" title="Determine whether a string ends with another string.">ends_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a271d1a7a22f79576570f63e939eb191a" title="Determine whether a string ends with a certain character.">ends_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#a1d5572dd02a7d92918dde5f75c18f559" title="Determine whether a string starts with a certain character.">starts_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#ae4e9cd4896149930f4b4eb9c127d2554" title="Determine whether a string contains a certain character.">contains_nocase(string_view, char)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="aad247f13c1c43036097c549f043c30fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad247f13c1c43036097c549f043c30fe">&#9670;&nbsp;</a></span>ends_with_nocase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::ends_with_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string ends with another string. </p>
<p>The comparison is case insensitive as far as ASCII characters are concerned (C locale). If the searched-for suffix is empty, the result is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The full string to be tested. </td></tr>
    <tr><td class="paramname">suffix</td><td>The suffix to be looked for at the end of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> ends with <code>suffix</code>, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a2591738dfca418424c6440f8762a8ba3" title="Determine whether a string ends with a certain character.">ends_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#a25c954601217f1c63884d1f9f767c338" title="Determine whether a string ends with another string.">ends_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19" title="Determine whether a string starts with another string.">starts_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164" title="Determine whether a string contains another string.">contains_nocase(string_view, string_view)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a05127f08f53568d1b4bd199137b76ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05127f08f53568d1b4bd199137b76ab8">&#9670;&nbsp;</a></span>equals_nocase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::equals_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string is equal to another one, making no distinction between upper and lower case ASCII characters. </p>
<p>In other terms, this function performs a case insensitive string comparison using the C locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1,str2</td><td>The two strings that should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ASCII-lowercase versions of <code>str1</code> and <code>str2</code> are equal, or false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164" title="Determine whether a string contains another string.">contains_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe" title="Determine whether a string ends with another string.">ends_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19" title="Determine whether a string starts with another string.">starts_with_nocase(string_view, string_view)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a881f0f6e3e283fb7558eaa336020cfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881f0f6e3e283fb7558eaa336020cfdf">&#9670;&nbsp;</a></span>escape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GUL_EXPORT std::string gul14::escape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string that looks like an ASCII-only C string literal of the input string. </p>
<p>This is achieved by replacing all non-printable and non-ASCII characters with a hex code escape in the form <code>\x01</code>.</p>
<p>A few special cases are implemented to give more readable representations for very common control characters, and of course backslash and double quotes are escaped as well: </p><pre class="fragment">CR   -&gt;  \r
NL   -&gt;  \n
TAB  -&gt;  \t
\    -&gt;  \\
"    -&gt;  \"
</pre><h4>Example</h4>
<div class="fragment"><div class="line">std::cout &lt;&lt; <a class="code" href="namespacegul14.html#a881f0f6e3e283fb7558eaa336020cfdf">escape</a>(<span class="stringliteral">&quot;Zwei\tFlüsse\nfließen ins Meer.&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p> Output (assuming that the string literal was in Latin-1 encoding): </p><pre class="fragment">Zwei\tFl\xfcsse\nflie\xdfen ins Meer.
</pre><dl class="section note"><dt>Note</dt><dd>The hexadecimal escape always uses two digits. This is different from the C/C++ standard, where it can be an arbitrary number of digits. The standard's way makes it impossible to have any hex digit after a hex escape, e.g. <code>"\x200"</code> is invalid and not equal to <code>" 0"</code> from the standard's point of view.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string that contains only ASCII characters.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.4 parameter <b>in</b> is a string_view (was std::string before) </dd></dl>

</div>
</div>
<a id="a4351c9c060eb9cefc28793e11d3932a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4351c9c060eb9cefc28793e11d3932a5">&#9670;&nbsp;</a></span>finally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1FinalAction.html">FinalAction</a>&lt;typename std::decay_t&lt;F&gt; &gt; gul14::finally </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacegul14.html#a4351c9c060eb9cefc28793e11d3932a5" title="finally() - convenience function to generate a FinalAction">finally()</a> - convenience function to generate a <a class="el" href="classgul14_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> </p>
<p>A <a class="el" href="classgul14_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> can be used to add RAII like behavior for non RAII object or to do timing measurements. More information given in the <a class="el" href="classgul14_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> documentation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the closure/function to be called (normally autodeduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The closure or pointer to function to be called on destruction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.1 </dd></dl>

</div>
</div>
<a id="aa73c01eba4544c9744ed896594c12370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73c01eba4544c9744ed896594c12370">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename E , std::size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gul14::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1span.html">span</a>&lt; E, S &gt;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; decltype(s[N])
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the Nth element of a given span. </p>
<p>This is a backport from the C++20 standard library, see: <a href="https://en.cppreference.com/w/cpp/container/span/get">https://en.cppreference.com/w/cpp/container/span/get</a></p>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.9 </dd></dl>

</div>
</div>
<a id="a25afcbd157fb5ea3b532097d4226cfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25afcbd157fb5ea3b532097d4226cfab">&#9670;&nbsp;</a></span>hex_string() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; IsContainerLike&lt; Container &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::hex_string </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hexadecimal ASCII representation of a container with integer values. </p>
<p>The letters 'a' to 'f' are used in lowercase, and no separators are inserted between individual values. </p><div class="fragment"><div class="line">std::array&lt;unsigned char, 4&gt; values = { 0, 15, 16, 255 };</div>
<div class="line">assert(<a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(values) == <span class="stringliteral">&quot;000f10ff&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Input container </td></tr>
    <tr><td class="paramname">separator</td><td>A string that is inserted between the elements to separate them visually (empty by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>must be a <a class="el" href="structgul14_1_1IsContainerLike.html" title="Helper type trait object to determine if a type is a container.">gul14::IsContainerLike</a> class</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.6 </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string()</a>.</p>

</div>
</div>
<a id="aa52554b24668d3d37657197b2b7fe0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52554b24668d3d37657197b2b7fe0dc">&#9670;&nbsp;</a></span>hex_string() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer , size_t num_elements, std::enable_if_t&lt; std::is_integral&lt; Integer &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::hex_string </td>
          <td>(</td>
          <td class="paramtype">const Integer(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[num_elements], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hexadecimal ASCII representation of an array with integer values. </p>
<p>The letters 'a' to 'f' are used in lowercase, and a user-defined separator can be inserted between individual values. </p><div class="fragment"><div class="line">uint16_t values[] = { 256, 255 };</div>
<div class="line">assert(<a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(values) == <span class="stringliteral">&quot;010000ff&quot;</span>);</div>
<div class="line">assert(<a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(values, <span class="stringliteral">&quot;-&quot;</span>) == <span class="stringliteral">&quot;0100-00ff&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array </td></tr>
    <tr><td class="paramname">separator</td><td>A string that is inserted between the elements to separate them visually (empty by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>must be an integral type. </td></tr>
    <tr><td class="paramname">num_elements</td><td>is the number of array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.6 </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string()</a>.</p>

</div>
</div>
<a id="adbaca240c1cd99e9a477f8c2eb8b8880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaca240c1cd99e9a477f8c2eb8b8880">&#9670;&nbsp;</a></span>hex_string() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral&lt; Integer &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::hex_string </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hexadecimal ASCII representation of an integer value. </p>
<p>The letters 'a' to 'f' are used in lowercase, and the number of hex digits is twice the number of bytes in the input integer type.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(1)) == <span class="stringliteral">&quot;01&quot;</span></div>
<div class="line"><a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(255)) == <span class="stringliteral">&quot;ff&quot;</span>;</div>
<div class="line"><a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(uint32_t{ 256 }) == <span class="stringliteral">&quot;00000100&quot;</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input value</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>must be an integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.6 </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a8fa061a14b864c17593e03fa540d3a51">hex_digits</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#af73e60faf7662dcdaf7672e1302200f3">hex_string()</a>.</p>

</div>
</div>
<a id="af73e60faf7662dcdaf7672e1302200f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73e60faf7662dcdaf7672e1302200f3">&#9670;&nbsp;</a></span>hex_string() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::hex_string </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hexadecimal ASCII representation of a range of integer values. </p>
<p>The letters 'a' to 'f' are used in lowercase, and a user-defined separator can be inserted between individual values.</p>
<div class="fragment"><div class="line">std::array&lt;unsigned char, 4&gt; values = { 0, 15, 16, 255 };</div>
<div class="line">assert(<a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(values.begin(), values.end()) == <span class="stringliteral">&quot;000f10ff&quot;</span>);</div>
<div class="line">assert(<a class="code" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string</a>(values.begin(), values.end(), <span class="stringliteral">&quot;-&quot;</span>) == <span class="stringliteral">&quot;00-0f-10-ff&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element of the range </td></tr>
    <tr><td class="paramname">separator</td><td>A string that is inserted between the elements to separate them visually (empty by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>must be a forward iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.6 </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string()</a>.</p>

</div>
</div>
<a id="a8d057910c13cf2965109f1f5698a6c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d057910c13cf2965109f1f5698a6c42">&#9670;&nbsp;</a></span>hexdump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::hexdump </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>prompt</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Reference to the container whose contents should be dumped; the container must provide ForwardIterators for .cbegin() and .cend() </td></tr>
    <tr><td class="paramname">prompt</td><td>(optional) String that prefixes the dump text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the dump </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#ac7cb3c0cf75996829712e5849d3dd878">hexdump_stream()</a>.</p>

</div>
</div>
<a id="a2ad9d1a1cee23214a61491bfc8171595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad9d1a1cee23214a61491bfc8171595">&#9670;&nbsp;</a></span>hexdump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename  = std::enable_if_t&lt;detail::IsHexDumpIterator&lt;IteratorT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::hexdump </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>prompt</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a hexdump of a data range and return it as a string. </p>
<p>The elements of the data range must be of integral type. They are dumped as unsigned integer values with their native width: Chars as "00" to "ff", 16-bit integers as "0000" to "ffff", and so on. If the elements are of type char, also a textual representation of the printable characters is dumped. An optional prompt can be added in front of the hexdump.</p>
<div class="fragment"><div class="line">std::string x = <span class="stringliteral">&quot;test\nthe Ä west!\t\r\n&quot;</span>;</div>
<div class="line">std::string str = <a class="code" href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">gul14::hexdump</a>(x.begin(), x.end(), <span class="stringliteral">&quot;debug -&gt; &quot;</span>);</div>
<div class="line">std::cerr &lt;&lt; str;</div>
</div><!-- fragment --> <pre class="fragment">deBug -&gt; 000000: 74 65 73 74 0a 74 68 65 20 c3 84 20 77 65 73 74  test.the .. west
         000010: 21 09 0d 0a                                      !...
</pre><div class="fragment"><div class="line">std::array&lt;int, 8&gt; ar = {{ 0, 1, 5, 2, -0x300fffff, 2, 5, 1999 }};</div>
<div class="line">std::string str = <a class="code" href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">gul14::hexdump</a>(begin(ar), end(ar));</div>
<div class="line">std::cout &lt;&lt; str;</div>
</div><!-- fragment --> <pre class="fragment">000000: 00000000 00000001 00000005 00000002 cff00001 00000002 00000005 000007cf
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>ForwardIterator to the first data element to be dumped </td></tr>
    <tr><td class="paramname">end</td><td>ForwardIterator past the last data element to be dumped </td></tr>
    <tr><td class="paramname">prompt</td><td>(optional) String that prefixes the dump text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the dump </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#ac7cb3c0cf75996829712e5849d3dd878">hexdump_stream()</a>.</p>

</div>
</div>
<a id="a712f6744dc70db3fa371397b3378d87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712f6744dc70db3fa371397b3378d87c">&#9670;&nbsp;</a></span>hexdump_stream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt;const decltype(std::declval&lt;ContainerT&gt;).cbegin())&gt; gul14::hexdump_stream </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prompt</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Reference to the container to dump </td></tr>
    <tr><td class="paramname">prompt</td><td>(optional) String that prefixes the dump text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a helper object to be used with operator&lt;&lt; on streams </dd></dl>

</div>
</div>
<a id="ad3b2d42f1a3c17d56d8b4fa8dfddbf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">&#9670;&nbsp;</a></span>hexdump_stream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename  = std::enable_if_t&lt;detail::IsHexDumpIterator&lt;IteratorT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt;const IteratorT&gt; gul14::hexdump_stream </td>
          <td>(</td>
          <td class="paramtype">const IteratorT &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorT &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prompt</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a hexdump of a data range that can be efficiently written to a stream using operator&lt;&lt;. </p>
<p>Where <a class="el" href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595" title="Generate a hexdump of a data range and return it as a string.">hexdump()</a> writes all of its output into one monolithic string, <a class="el" href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b" title="Generate a hexdump of a data range that can be efficiently written to a stream using operator&lt;&lt;.">hexdump_stream()</a> returns a tiny helper object that can efficiently send its output to an output stream via operator&lt;&lt;. This means that the following two lines produce the exact same output, but the stream version uses less resources: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <a class="code" href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">gul14::hexdump_stream</a>(x.begin(), x.end()) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// good</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">gul14::hexdump</a>(x.begin(), x.end()) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// also good, but allocates a temporary string</span></div>
</div><!-- fragment --><p>The elements of the data range must be of integral type. They are dumped as unsigned integer values with their native width: Chars as "00" to "ff", 16-bit integers as "0000" to "ffff", and so on. If the elements are of type char, also a textual representation of the printable characters is dumped. An optional prompt can be added in front of the hexdump.</p>
<div class="fragment"><div class="line">std::string x = <span class="stringliteral">&quot;test\nthe Ä west!\t\r\n&quot;</span>;</div>
<div class="line">std::cerr &lt;&lt; <a class="code" href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">gul14::hexdump_stream</a>(x.begin(), x.end(), <span class="stringliteral">&quot;debug -&gt; &quot;</span>);</div>
</div><!-- fragment --> <pre class="fragment">debug -&gt; 000000: 74 65 73 74 0a 74 68 65 20 c3 84 20 77 65 73 74  test.the .. west
         000010: 21 09 0d 0a                                      !...
</pre><div class="fragment"><div class="line">std::array&lt;int, 8&gt; ar = {{ 0, 1, 5, 2, -0x300fffff, 2, 5, 1999 }};</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">gul14::hexdump_stream</a>(begin(ar), end(ar));</div>
</div><!-- fragment --> <pre class="fragment">000000: 00000000 00000001 00000005 00000002 cff00001 00000002 00000005 000007cf
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>ForwardIterator to the first data to be dumped </td></tr>
    <tr><td class="paramname">end</td><td>ForwardIterator past the last data element to be dumped </td></tr>
    <tr><td class="paramname">prompt</td><td>(optional) String that prefixes the dump text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a helper object to be used with operator&lt;&lt; on streams </dd></dl>

</div>
</div>
<a id="ac7cb3c0cf75996829712e5849d3dd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cb3c0cf75996829712e5849d3dd878">&#9670;&nbsp;</a></span>hexdump_stream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value,        decltype(HexdumpParameterForward&lt;decltype(std::declval&lt;ContainerT&gt;().cbegin()),                     ContainerT&gt; {}, 0)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt;decltype(std::declval&lt;ContainerT&gt;).cbegin()), ContainerT&gt; gul14::hexdump_stream </td>
          <td>(</td>
          <td class="paramtype">ContainerT &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prompt</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Reference to the container to dump if is a temporary </td></tr>
    <tr><td class="paramname">prompt</td><td>(optional) String that prefixes the dump text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a helper object to be used with operator&lt;&lt; on streams </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">hexdump()</a>.</p>

</div>
</div>
<a id="a0b05ef3db1b337691307dada4bb755aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b05ef3db1b337691307dada4bb755aa">&#9670;&nbsp;</a></span>join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::join </td>
          <td>(</td>
          <td class="paramtype">const StringContainer &amp;&#160;</td>
          <td class="paramname"><em>parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>glue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate all strings in a range, placing a delimiter between them. </p>
<p>This algorithm iterates twice over the range in order to pre-allocate a string of the correct size.</p>
<p>This is the inverse function of <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a>. It is guaranteed that <code>join(split(text, del), del) == text</code> (unless del is a std::regex object).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parts</td><td>A container holding strings or string views that are to be concatenated </td></tr>
    <tr><td class="paramname">glue</td><td>String that is put between each element of parts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all strings glued together with the delimiter glue.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringContainer</td><td>A container type that holds strings, e.g. std::vector&lt;std::string&gt; or std::list&lt;gul14::string_view&gt;. The container must provide an STL-like forward iterator interface. The string type must support concatenation with std::string using operator+=.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a00a75d4171ca190a68f266d5a6c364f9" title="Concatenate all strings in a range, placing a delimiter between them.">join(Iterator, Iterator, string_view)</a> has a two-iterator interface, <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a> and associated functions can be used to <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split</a> a string into a vector of substrings.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.3, <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join()</a> accepts arbitrary containers or iterators (it was limited to std::vector before). </dd></dl>

</div>
</div>
<a id="a00a75d4171ca190a68f266d5a6c364f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a75d4171ca190a68f266d5a6c364f9">&#9670;&nbsp;</a></span>join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::join </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>glue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate all strings in a range, placing a delimiter between them. </p>
<p>This algorithm iterates twice over the range in order to pre-allocate a string of the correct size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the first string </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing past the last string </td></tr>
    <tr><td class="paramname">glue</td><td>String that is put between each element of parts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all strings glued together with the delimiter glue.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>A forward iterator type that dereferences to a string type. The string type must support concatenation with std::string using operator+=.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>join(StringContainer, string_view) is a convenience overload for joining entire containers, <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a> and associated functions can be used to <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split</a> a string into a vector of substrings.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.3 </dd></dl>

</div>
</div>
<a id="a5dd41f38bbdde29c2a0ef7e5864d9052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd41f38bbdde29c2a0ef7e5864d9052">&#9670;&nbsp;</a></span>lowercase_ascii() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char gul14::lowercase_ascii </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ASCII lowercase equivalent of the given character (or the unchanged character, if it is not an ASCII letter). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The original character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a9d6d216830d66a060c66ceb8e18f5e90" title="Return a copy of the given string in which all ASCII characters are replaced by their lowercase equiv...">lowercase_ascii(gul14::string_view)</a>, <a class="el" href="namespacegul14.html#a3cdcecf4d343173209f4bcb5fee32bff" title="Replace all ASCII characters in a string by their lowercase equivalents.">lowercase_ascii_inplace(std::string &amp;)</a>, <a class="el" href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a" title="Return the ASCII uppercase equivalent of the given character (or the unchanged character,...">uppercase_ascii(char)</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164">contains_nocase()</a>, <a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe">ends_with_nocase()</a>, <a class="el" href="namespacegul14.html#a05127f08f53568d1b4bd199137b76ab8">equals_nocase()</a>, <a class="el" href="namespacegul14.html#a9d6d216830d66a060c66ceb8e18f5e90">lowercase_ascii()</a>, <a class="el" href="namespacegul14.html#a3cdcecf4d343173209f4bcb5fee32bff">lowercase_ascii_inplace()</a>, and <a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19">starts_with_nocase()</a>.</p>

</div>
</div>
<a id="a9d6d216830d66a060c66ceb8e18f5e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6d216830d66a060c66ceb8e18f5e90">&#9670;&nbsp;</a></span>lowercase_ascii() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::lowercase_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the given string in which all ASCII characters are replaced by their lowercase equivalents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The original string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052" title="Return the ASCII lowercase equivalent of the given character (or the unchanged character,...">lowercase_ascii(char)</a>, <a class="el" href="namespacegul14.html#a3cdcecf4d343173209f4bcb5fee32bff" title="Replace all ASCII characters in a string by their lowercase equivalents.">lowercase_ascii_inplace(std::string &amp;)</a>, <a class="el" href="namespacegul14.html#a6d3dd7d06bd977bcf832d7d9f00c9f0a" title="Return a copy of the given string in which all ASCII characters are replaced by their uppercase equiv...">uppercase_ascii(gul14::string_view)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a3cdcecf4d343173209f4bcb5fee32bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdcecf4d343173209f4bcb5fee32bff">&#9670;&nbsp;</a></span>lowercase_ascii_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; gul14::lowercase_ascii_inplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all ASCII characters in a string by their lowercase equivalents. </p>
<p>This function modifies the original string and returns a reference to it (which may be helpful for chaining function calls). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the string argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052" title="Return the ASCII lowercase equivalent of the given character (or the unchanged character,...">lowercase_ascii(char)</a>, <a class="el" href="namespacegul14.html#a9d6d216830d66a060c66ceb8e18f5e90" title="Return a copy of the given string in which all ASCII characters are replaced by their lowercase equiv...">lowercase_ascii(gul14::string_view)</a>, <a class="el" href="namespacegul14.html#af94d4383c549025201f317b6cce4c781" title="Replace all ASCII characters in a string by their uppercase equivalents.">uppercase_ascii_inplace(std::string &amp;)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a78b824c80d48bff9d5ec5c42950dc279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b824c80d48bff9d5ec5c42950dc279">&#9670;&nbsp;</a></span>maximum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::maximum </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum element value in a container. </p>
<p>The value of each element is determined through the accessor function. The maximum value is returned. Its type (DataT, the return type of the accessor) must provide <code>operator==()</code> and <code>operator&lt;=()</code>. If DataT supports not-a-number (NaN) values, such values are ignored. If the container is empty, the return value is NaN (if supported) or <code>std::numeric_limits&lt;DataT&gt;::lowest()</code>.</p>
<p>Hint: If looking for an iterator to the maximum element instead of its value, use <code>std::max_element()</code> from the STL algorithm collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a5b7ed06f5c069bf60497a952cdd21724" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">maximum(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container.<br  />
<a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6" title="Return the minimum element value in a container.">minimum()</a> returns the <a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6" title="Return the minimum element value in a container.">minimum</a> value, <a class="el" href="namespacegul14.html#a34990e623ef0dacabedd01defd200599" title="Find the minimum and maximum element values in a container.">min_max()</a> returns both the <a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6" title="Return the minimum element value in a container.">minimum</a> and the <a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279" title="Return the maximum element value in a container.">maximum</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.2 </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="a5b7ed06f5c069bf60497a952cdd21724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7ed06f5c069bf60497a952cdd21724">&#9670;&nbsp;</a></span>maximum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::maximum </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>max(ContainerT const&amp;, Accessor) accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="a06b75f0d2f5432534ce5016f4f6133e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b75f0d2f5432534ce5016f4f6133e2">&#9670;&nbsp;</a></span>mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::mean </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the arithmetic mean value of all elements in a container. </p>
<p>The mean value is calculated by dividing the sum of all elements by the number of elements: <code>mean -&gt; sum 0..n-1 (element i) / n</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the arithmetic mean value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result (this is also the type used for holding the sum of all elements and for the division by the number of elements, so make sure it can hold numbers that are big enough) </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a07b40114e8bab88bb79c0e0b1120e9e5" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">mean(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="a07b40114e8bab88bb79c0e0b1120e9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b40114e8bab88bb79c0e0b1120e9e5">&#9670;&nbsp;</a></span>mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::mean </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2" title="Calculate the arithmetic mean value of all elements in a container.">mean(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#acfd9a11052c0ce4d3715cb4a405026d3">remove_outliers()</a>.</p>

</div>
</div>
<a id="a3754c8155dbab769a73179dc794b5258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3754c8155dbab769a73179dc794b5258">&#9670;&nbsp;</a></span>median() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::median </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the median of all elements in a container. </p>
<p>The median element is the element that has an equal number of elements higher and lower in value. If the container has an even number of elements there can be no 'middle' element. In this case the two 'middlemost' elements are taken and the arithmetic mean of the two is returned.</p>
<p>Because all elements need to be sorted, the function works with a temporary copy of the original container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the median value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ae315105546e683a5660d30b3eafef51a" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">median(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

</div>
</div>
<a id="ae315105546e683a5660d30b3eafef51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae315105546e683a5660d30b3eafef51a">&#9670;&nbsp;</a></span>median() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::median </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a3754c8155dbab769a73179dc794b5258" title="Find the median of all elements in a container.">median(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="a34990e623ef0dacabedd01defd200599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34990e623ef0dacabedd01defd200599">&#9670;&nbsp;</a></span>min_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::min_max </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structgul14_1_1MinMax.html">MinMax</a>&lt;DataT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum and maximum element values in a container. </p>
<p>The value of each element is determined through the accessor function. The minimum and the maximum of these values are returned. Their type (DataT, the return type of the accessor) must provide <code>operator==(),</code>operator&lt;=()<code>, and</code>operator&gt;=()`. If DataT supports not-a-number (NaN) values, such values are ignored. If the container is empty, the return values are NaN (if supported) or <code>std::numeric_limits&lt;DataT&gt;::max()</code> for the minimum and <code>std::numeric_limits&lt;DataT&gt;::lowest()</code> for the maximum.</p>
<p>This behaves like (symbolic code): </p><div class="fragment"><div class="line">std::minmax_element(std::transform(mycontainer, accessor))</div>
</div><!-- fragment --><p> without constructing a temporary container and without the ownership problems that would arise from minmax_element usage on a temporary container.</p>
<p>Hint: If looking for iterators to the minimum and maximum element instead of their values, use <code>std::minmax_element()</code> from the STL algorithm collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum and maximum values stored in a MinMax&lt;DataT&gt; object.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a6b39ec77e4f4f4e773a93313d36f5da8" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">min_max(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container.<br  />
<a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6" title="Return the minimum element value in a container.">minimum()</a> returns only the <a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6" title="Return the minimum element value in a container.">minimum</a> value, <a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279" title="Return the maximum element value in a container.">maximum()</a> only the <a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279" title="Return the maximum element value in a container.">maximum</a> value. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="a6b39ec77e4f4f4e773a93313d36f5da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b39ec77e4f4f4e773a93313d36f5da8">&#9670;&nbsp;</a></span>min_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::min_max </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structgul14_1_1MinMax.html">MinMax</a>&lt;DataT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a34990e623ef0dacabedd01defd200599" title="Find the minimum and maximum element values in a container.">min_max(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="a5b0eef398fee8267047205743a451da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0eef398fee8267047205743a451da6">&#9670;&nbsp;</a></span>minimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::minimum </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum element value in a container. </p>
<p>The value of each element is determined through the accessor function. The minimum value is returned. Its type (DataT, the return type of the accessor) must provide <code>operator==()</code> and <code>operator&gt;=()</code>. If DataT supports not-a-number (NaN) values, such values are ignored. If the container is empty, the return value is NaN (if supported) or <code>std::numeric_limits&lt;DataT&gt;::max()</code>.</p>
<p>Hint: If looking for an iterator to the minimum element instead of its value, use <code>std::min_element()</code> from the STL algorithm collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ac0c54558fdb27f24eb6b1289da65f9ea" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">minimum(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container.<br  />
<a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279" title="Return the maximum element value in a container.">maximum()</a> returns the <a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279" title="Return the maximum element value in a container.">maximum</a> value, <a class="el" href="namespacegul14.html#a34990e623ef0dacabedd01defd200599" title="Find the minimum and maximum element values in a container.">min_max()</a> returns both the <a class="el" href="namespacegul14.html#a5b0eef398fee8267047205743a451da6" title="Return the minimum element value in a container.">minimum</a> and the <a class="el" href="namespacegul14.html#a78b824c80d48bff9d5ec5c42950dc279" title="Return the maximum element value in a container.">maximum</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.2 </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="ac0c54558fdb27f24eb6b1289da65f9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c54558fdb27f24eb6b1289da65f9ea">&#9670;&nbsp;</a></span>minimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::minimum </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>max(ContainerT const&amp;, Accessor) accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="acfd9a11052c0ce4d3715cb4a405026d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd9a11052c0ce4d3715cb4a405026d3">&#9670;&nbsp;</a></span>remove_outliers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">ContainerT &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>outliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ContainerT&amp;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove elements that are far away from other elements. </p>
<p>The element whose value differs the most from the arithmetic mean of all elements is removed. This process is repeated if more than one outlier is to be removed; specifically, the mean is recalculated from the remaining elements.</p>
<p>The original container is modified. The container needs to be modifiable and have the <code>erase()</code> member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">outliers</td><td>How many outliers shall be removed </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the container passed in as <code>cont</code> after removal of outliers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c">abs()</a>, and <a class="el" href="namespacegul14.html#a07b40114e8bab88bb79c0e0b1120e9e5">mean()</a>.</p>

</div>
</div>
<a id="a71c8faba2570251d314f445455e7f4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c8faba2570251d314f445455e7f4a2">&#9670;&nbsp;</a></span>remove_outliers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>outliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;ElementT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified. </p>
<p>A copy of the original container without the outlier elements is returned. </p>

<p class="reference">References <a class="el" href="namespacegul14.html#a401025215ceed0e841b6f5339aecea98">remove_outliers()</a>.</p>

</div>
</div>
<a id="a401025215ceed0e841b6f5339aecea98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401025215ceed0e841b6f5339aecea98">&#9670;&nbsp;</a></span>remove_outliers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>outliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;ElementT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified. </p>
<p>A copy of the original container with the outerlier elements removed is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">outliers</td><td>How many outliers shall be removed </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a71c8faba2570251d314f445455e7f4a2">remove_outliers()</a>.</p>

</div>
</div>
<a id="a9801de6999c42b6e2987a55532057a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9801de6999c42b6e2987a55532057a4c">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>hammer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a string within another string, returning the result as a std::string. </p>
<p>Specifically, replace all occurrences of needle within haystack by hammer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string in which search&amp;replace should take place. </td></tr>
    <tr><td class="paramname">needle</td><td>The string to be searched for. If this is an empty string, a copy of haystack is returned. </td></tr>
    <tr><td class="paramname">hammer</td><td>The replacement string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a9ff5d5ab6febb6c74a83e6442c2cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9ff5d5ab6febb6c74a83e6442c2cd1">&#9670;&nbsp;</a></span>replace_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; gul14::replace_inplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>hammer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a string within another string in-place. </p>
<p>This function replaces all occurrences of needle within haystack by hammer and returns a reference to the modified haystack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string in which search&amp;replace should take place. </td></tr>
    <tr><td class="paramname">needle</td><td>The string to be searched for. If this is an empty string, haystack is not changed. </td></tr>
    <tr><td class="paramname">hammer</td><td>The replacement string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the altered haystack. </dd></dl>

</div>
</div>
<a id="ad65eba81972f8d5fcf326d16f28eadb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65eba81972f8d5fcf326d16f28eadb1">&#9670;&nbsp;</a></span>rms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::rms </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the root mean square of all elements in a container. </p>
<p>The rms value is calculated as the square root of the sum of all squared elements divided by the number of elements: <code>rms -&gt; sqrt (sum 0..n-1 (element i * element i) / n)</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rms value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#abf56fb354125c39033dbd092b6da35fb" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">rms(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="abf56fb354125c39033dbd092b6da35fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf56fb354125c39033dbd092b6da35fb">&#9670;&nbsp;</a></span>rms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::rms </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad65eba81972f8d5fcf326d16f28eadb1" title="Calculate the root mean square of all elements in a container.">rms(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="af05731d015fe2827d95fffd6432ba74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05731d015fe2827d95fffd6432ba74d">&#9670;&nbsp;</a></span>safe_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::safe_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>char_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely construct a std::string from a char pointer and a length. </p>
<p>If the pointer is null, an empty string is constructed. If there are no zero bytes in the input range, a string of length <code>length</code> is constructed. Otherwise, the input string is treated as a C string and the first zero byte is treated as the end of the string.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code" href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">safe_string</a>(<span class="keyword">nullptr</span>, 5);  <span class="comment">// a == &quot;&quot;s</span></div>
<div class="line"><span class="keyword">auto</span> b = <a class="code" href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">safe_string</a>(<span class="stringliteral">&quot;ABC&quot;</span>, 2);    <span class="comment">// b == &quot;AB&quot;s</span></div>
<div class="line"><span class="keyword">auto</span> c = <a class="code" href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">safe_string</a>(<span class="stringliteral">&quot;ABC&quot;</span>, 4);    <span class="comment">// c == &quot;ABC&quot;s, trailing zero byte ends the string</span></div>
<div class="line"><span class="keyword">auto</span> d = <a class="code" href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">safe_string</a>(<span class="stringliteral">&quot;AB\0CD&quot;</span>, 5); <span class="comment">// d == &quot;AB&quot;s, intermediate zero byte ends the string</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_ptr</td><td>Pointer to a C string, an unterminated string of at least the specified length, or null. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length of the generated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.6 </dd></dl>

</div>
</div>
<a id="ac510f7b538a9b9eab94b885e60703214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac510f7b538a9b9eab94b885e60703214">&#9670;&nbsp;</a></span>sleep() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::sleep </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep for a given time span. </p>
<p>This is equivalent to a call of std::this_thread::sleep_for(), which means that control is handed back to the operating system's task scheduler. This may result in a somewhat bigger effective delay than expected, especially where very small sleep times are requested and the system load is high.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::literals; <span class="comment">// for the &quot;ms&quot; suffix</span></div>
<div class="line"><a class="code" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">sleep</a>(50ms); <span class="comment">// Wait 50 milliseconds</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Time span to wait, as a std::chrono::duration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to signalize that the entire requested sleep duration has passed. This is for symmetry with the interruptible version of <a class="el" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc" title="Sleep for a given time span, with the option of being woken up from another thread.">sleep()</a> only. </dd></dl>

</div>
</div>
<a id="aa0abe7bf6452e6882c0e0b0d05897adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0abe7bf6452e6882c0e0b0d05897adc">&#9670;&nbsp;</a></span>sleep() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::sleep </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1Trigger.html">Trigger</a> &amp;&#160;</td>
          <td class="paramname"><em>trg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep for a given time span, with the option of being woken up from another thread. </p>
<p>The sleep can be interrupted from another thread via a shared <a class="el" href="classgul14_1_1Trigger.html">Trigger</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Time span to wait, as a std::chrono::duration type. </td></tr>
    <tr><td class="paramname">trg</td><td>Reference to a SleepInterrupt object that can be used to interrupt the delay. If such an interruption occurs, false is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entire requested sleep duration has passed, or false if the sleep has been interrupted prematurely via the <a class="el" href="classgul14_1_1Trigger.html" title="A class that allows sending triggers and waiting for them across different threads.">Trigger</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul14_1_1Trigger.html">Trigger</a> </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1Trigger.html#ad22d4a3c46b975b95ff7e4073897d7a0">gul14::Trigger::wait_for()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#aa7b3b3ee304683df1af8c8f921bc9d6b">sleep()</a>.</p>

</div>
</div>
<a id="a7bbed53d6d2a8cef5208d06fa6e67cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbed53d6d2a8cef5208d06fa6e67cbf">&#9670;&nbsp;</a></span>sleep() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::sleep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sleep for a given number of seconds. </p>
<p>This is equivalent to a call of std::this_thread::sleep_for(), which means that control is handed back to the operating system's task scheduler. This may result in a somewhat bigger effective delay than expected, especially where very small sleep times are requested and the system load is high.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">sleep</a>(0.05); <span class="comment">// Wait 50 milliseconds</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>Seconds to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to signalize that the entire requested sleep duration has passed. This is for symmetry with the interruptible version of <a class="el" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc" title="Sleep for a given time span, with the option of being woken up from another thread.">sleep()</a> only. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">sleep()</a>.</p>

</div>
</div>
<a id="aa7b3b3ee304683df1af8c8f921bc9d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b3b3ee304683df1af8c8f921bc9d6b">&#9670;&nbsp;</a></span>sleep() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::sleep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1Trigger.html">Trigger</a> &amp;&#160;</td>
          <td class="paramname"><em>trg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sleep for a given number of seconds, with the option of being woken up from another thread. </p>
<p>The sleep can be interrupted from another thread via a shared <a class="el" href="classgul14_1_1Trigger.html">Trigger</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>Seconds to wait. </td></tr>
    <tr><td class="paramname">trg</td><td>Reference to a SleepInterrupt object that can be used to interrupt the delay. If such an interruption occurs, false is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entire requested sleep duration has passed, or false if the sleep has been interrupted prematurely via the <a class="el" href="classgul14_1_1Trigger.html" title="A class that allows sending triggers and waiting for them across different threads.">Trigger</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul14_1_1Trigger.html">Trigger</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">sleep()</a>.</p>

</div>
</div>
<a id="a99682f92a890dcdc6cfc194142a2203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99682f92a890dcdc6cfc194142a2203f">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringContainer gul14::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::regex &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerInsertFct&#160;</td>
          <td class="paramname"><em>insert_fct</em> = <code>detail::emplace_back&lt;StringContainer&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separate a string at all occurrences of a delimiter described by a regular expression, returning the strings between the delimiters in a container. </p>
<p>This function is a variant of <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split(string_view, string_view, ContainerInsertFct)</a> that accepts a std::regex object to describe the delimiter: </p><div class="fragment"><div class="line"><span class="comment">// Return type is std::vector&lt;std::string&gt;</span></div>
<div class="line"><span class="keyword">auto</span> parts = <a class="code" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9">split</a>(<span class="stringliteral">&quot;one\ntwo\nthree&quot;</span>s, std::regex{<span class="stringliteral">&quot;[^[:print:]]&quot;</span>});</div>
<div class="line">assert(y.size() == 3);</div>
<div class="line">assert(y[0] == <span class="stringliteral">&quot;one&quot;</span>s);</div>
<div class="line">assert(y[1] == <span class="stringliteral">&quot;two&quot;</span>s);</div>
<div class="line">assert(y[2] == <span class="stringliteral">&quot;three&quot;</span>s);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to be split </td></tr>
    <tr><td class="paramname">delimiter</td><td>A std::regex object describing the delimiters </td></tr>
    <tr><td class="paramname">insert_fct</td><td>Custom container inserter function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split(string_view, string_view, ContainerInsertFct)</a> splits at a fixed substring,<br  />
 <a class="el" href="namespacegul14.html#a71226668835d574ccad136939940191f" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split_sv()</a> does the same returning a vector of string_views, and<br  />
 <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join()</a> can <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join</a> the vector back into a string. </dd></dl>

</div>
</div>
<a id="a0e6eed5ed768613f3680866905ca82b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6eed5ed768613f3680866905ca82b9">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringContainer gul14::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerInsertFct&#160;</td>
          <td class="paramname"><em>insert_fct</em> = <code>detail::emplace_back&lt;StringContainer&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in a container. </p>
<p>The result has at least one element. If the delimiter is not present in the text, the whole text is returned. If there are consecutive delimiters, the collected string between them is the empty string. If the delimiter is directly at the end of the input, the collected string between the end of the input and the delimiter is again the empty string.</p>
<p><a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a> is the inverse function of <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join()</a>. It is guaranteed that <code>join(split(text, del), del) == text</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; parts1 = <a class="code" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9">split</a>(<span class="stringliteral">&quot; hello world&quot;</span>, <span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line">assert(parts1.size() == 3);</div>
<div class="line">assert(parts1[0] == <span class="stringliteral">&quot;&quot;</span>s);</div>
<div class="line">assert(parts1[1] == <span class="stringliteral">&quot;hello&quot;</span>s);</div>
<div class="line">assert(parts1[2] == <span class="stringliteral">&quot;world&quot;</span>s);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::string&gt; parts2 = <a class="code" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9">split</a>(<span class="stringliteral">&quot;&lt;&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;&gt;&quot;</span>);</div>
<div class="line">assert(parts2.size() == 2);</div>
<div class="line">assert(parts2[0] == <span class="stringliteral">&quot;&quot;</span>s);</div>
<div class="line">assert(parts2[1] == <span class="stringliteral">&quot;&quot;</span>s);</div>
</div><!-- fragment --><p>This function returns a <code>std::vector&lt;std::string&gt;</code> by default, but a compatible container for string/string_view types can be specified via a template parameter:</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringContainer</td><td>A container for strings or string_view-like types, e.g. std::vector&lt;std::string&gt; or std::list&lt;gul14::string_view&gt; </td></tr>
    <tr><td class="paramname">ContainerInsertFct</td><td>Type for the <code>insert_fct</code> function parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to be split </td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiting substring </td></tr>
    <tr><td class="paramname">insert_fct</td><td>By default, <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a> calls the <code>emplace_back()</code> member function on the container to insert strings. This parameter may contain a different function pointer or object with the signature <code>void f(StringContainer&amp;, gul14::string_view)</code> that is called instead. This can be useful for containers that do not provide <code>emplace_back()</code> or for other customizations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container filled with the substrings that were separated by delimiter in the original string.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Different string type</span></div>
<div class="line"><span class="keyword">auto</span> parts1 = split&lt;std::vector&lt;gul14::string_view&gt;&gt;(<span class="stringliteral">&quot;Hello world&quot;</span>, <span class="stringliteral">&quot; &quot;</span>); <span class="comment">// behaves like split_sv()</span></div>
<div class="line">assert(parts1.size() == 2);</div>
<div class="line">assert(parts1[0] == <span class="stringliteral">&quot;Hello&quot;</span>); <span class="comment">// No lifetime problems because &quot;Hello world&quot; is a</span></div>
<div class="line">assert(parts1[1] == <span class="stringliteral">&quot;world&quot;</span>); <span class="comment">// string literal with static storage duration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom container type</span></div>
<div class="line"><span class="keyword">auto</span> parts2 = split&lt;gul14::SmallVector&lt;std::string, 3&gt;&gt;(<span class="stringliteral">&quot;a--b--c&quot;</span>, <span class="stringliteral">&quot;--&quot;</span>);</div>
<div class="line">assert(parts2.size() == 3);</div>
<div class="line">assert(parts2[0] == <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">assert(parts2[1] == <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">assert(parts2[2] == <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For a container without emplace_back(), use a custom inserter:</span></div>
<div class="line"><span class="keyword">using</span> WeirdContainer = std::queue&lt;std::string&gt;;</div>
<div class="line"><span class="keyword">auto</span> inserter = [](WeirdContainer&amp; c, <a class="code" href="classgul14_1_1basic__string__view.html">gul14::string_view</a> sv) { c.emplace(sv); };</div>
<div class="line"><span class="keyword">auto</span> parts3 = split&lt;WeirdContainer&gt;(<span class="stringliteral">&quot;a.b&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, inserter);</div>
<div class="line">assert(parts3.size() == 2);</div>
<div class="line">assert(parts3.front() == <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">assert(parts3.back() == <span class="stringliteral">&quot;b&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a71226668835d574ccad136939940191f" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split_sv()</a> returns a vector of string_views,<br  />
 split(const std::string&amp;, const std::regex&amp;) splits at a delimiter described by a regular expression, and<br  />
 <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join()</a> can <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join</a> the vector back into a string.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.5, the return type of <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a> can be specified as a template parameter and a custom inserter can be specified (it always returned std::vector&lt;std::string&gt; before). </dd></dl>

</div>
</div>
<a id="a71226668835d574ccad136939940191f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71226668835d574ccad136939940191f">&#9670;&nbsp;</a></span>split_sv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringContainer  = std::vector&lt;string_view&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringContainer gul14::split_sv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerInsertFct&#160;</td>
          <td class="paramname"><em>insert_fct</em> = <code>detail::emplace_back&lt;StringContainer&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in a vector. </p>
<p>This function is identical to <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split(string_view, string_view, ContainerInsertFct)</a> except that it returns a std::vector of string_views instead of strings by default: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> parts = <a class="code" href="namespacegul14.html#a71226668835d574ccad136939940191f">split_sv</a>(<span class="stringliteral">&quot;hello world&quot;</span>, <span class="stringliteral">&quot; &quot;</span>); <span class="comment">// Return type is std::vector&lt;gul14::string_view&gt;</span></div>
<div class="line">assert(parts.size() == 2);</div>
<div class="line">assert(parts[0] == <span class="stringliteral">&quot;hello&quot;</span>); <span class="comment">// No problems with lifetime because &quot;hello world&quot;</span></div>
<div class="line">assert(parts[1] == <span class="stringliteral">&quot;world&quot;</span>); <span class="comment">// is a string literal with static storage duration</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split(string_view, string_view, ContainerInsertFct)</a> returns a vector of strings,<br  />
 split(const std::string&amp;, const std::regex&amp;) splits at a delimiter described by a regular expression, and<br  />
 <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join()</a> can <a class="el" href="namespacegul14.html#a0b05ef3db1b337691307dada4bb755aa" title="Concatenate all strings in a range, placing a delimiter between them.">join</a> the vector back into a string.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.5, the return type of <a class="el" href="namespacegul14.html#a71226668835d574ccad136939940191f" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split_sv()</a> can be specified as a template parameter and a custom inserter can be specified (it always returned std::vector&lt;std::string&gt; before). </dd></dl>

</div>
</div>
<a id="a56bfa0fde0d5eb6c3367f1d55f2504b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bfa0fde0d5eb6c3367f1d55f2504b1">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classgul14_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt;ResultT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the standard deviation of all elements in a container. </p>
<p>The corrected sample standard deviation is calculated: <code>standard_deviation -&gt; sqrt (sum 0..n-1 ((element i - mean) * (element i - mean)) / (n - 1))</code></p>
<p>The returned <a class="el" href="classgul14_1_1StandardDeviationMean.html" title="A struct holding a standard deviation and a mean value.">StandardDeviationMean</a> object can be used like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> StandardDeviationMean std_and_mean = <a class="code" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">standard_deviation</a>(something);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> std = std_and_mean.sigma();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2">mean</a> = std_and_mean.mean();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The cast operator is for people that want to ignore the complicated stuff like this</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> std = <a class="code" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">standard_deviation</a>(something);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> std = <a class="code" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">standard_deviation</a>(something); <span class="comment">// implicit conversions possible</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Structured binding (C++17)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> [std, <a class="code" href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2">mean</a>] = <a class="code" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">standard_deviation</a>(something);</div>
</div><!-- fragment --><p>If the container is empty, not-a-number is returned for both the standard deviation and the mean value. If it contains only a single element, not-a-number is returned for the standard deviation and the mean value is the value of the element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the standard deviation and mean values as a <a class="el" href="classgul14_1_1StandardDeviationMean.html" title="A struct holding a standard deviation and a mean value.">StandardDeviationMean</a> object.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a7733f5947169eb1fcf6d5d56f05a5dde" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">standard_deviation(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#adccc162f651af3b868439e705aafae45">accumulate()</a>.</p>

</div>
</div>
<a id="a7733f5947169eb1fcf6d5d56f05a5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7733f5947169eb1fcf6d5d56f05a5dde">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="namespacegul14.html#a40910959ea2a39b4358547e620f33f13">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classgul14_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt;ResultT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1" title="Calculate the standard deviation of all elements in a container.">standard_deviation(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="ae36e065917e667674d910c4a1bede51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36e065917e667674d910c4a1bede51c">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string starts with a certain character. </p>
<p>The comparison is case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be tested. </td></tr>
    <tr><td class="paramname">c</td><td>The character to be looked for at the beginning of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> starts with <code>c</code>, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ad85883e07b4ec2e653b4fb255f4f04b8" title="Determine whether a string starts with another string.">starts_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a1d5572dd02a7d92918dde5f75c18f559" title="Determine whether a string starts with a certain character.">starts_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#a271d1a7a22f79576570f63e939eb191a" title="Determine whether a string ends with a certain character.">ends_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#a1f18f368f80a6e3f46c6cb9958f2536c" title="Determine whether a string contains a certain character.">contains(string_view, char)</a> </dd></dl>

</div>
</div>
<a id="ad85883e07b4ec2e653b4fb255f4f04b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85883e07b4ec2e653b4fb255f4f04b8">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string starts with another string. </p>
<p>The comparison is case sensitive. If the searched-for prefix is empty, the result is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The full string to be tested. </td></tr>
    <tr><td class="paramname">prefix</td><td>The prefix to be looked for at the beginning of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> starts with <code>prefix</code>, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#ae36e065917e667674d910c4a1bede51c" title="Determine whether a string starts with a certain character.">starts_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19" title="Determine whether a string starts with another string.">starts_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a25c954601217f1c63884d1f9f767c338" title="Determine whether a string ends with another string.">ends_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#adc3b2164aa4cb31da1adbba96a552573" title="Determine whether a string contains another string.">contains(string_view, string_view)</a> </dd></dl>

</div>
</div>
<a id="a1d5572dd02a7d92918dde5f75c18f559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5572dd02a7d92918dde5f75c18f559">&#9670;&nbsp;</a></span>starts_with_nocase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::starts_with_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string starts with a certain character. </p>
<p>The comparison is case insensitive as far as ASCII characters are concerned (C locale).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be tested. </td></tr>
    <tr><td class="paramname">c</td><td>The character to be looked for at the beginning of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> starts with <code>c</code>, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a9b555f8e8d57d41abbc5f3b1d5480c19" title="Determine whether a string starts with another string.">starts_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#ae36e065917e667674d910c4a1bede51c" title="Determine whether a string starts with a certain character.">starts_with(string_view, char)</a>, <a class="el" href="namespacegul14.html#a2591738dfca418424c6440f8762a8ba3" title="Determine whether a string ends with a certain character.">ends_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#ae4e9cd4896149930f4b4eb9c127d2554" title="Determine whether a string contains a certain character.">contains_nocase(string_view, char)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a9b555f8e8d57d41abbc5f3b1d5480c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b555f8e8d57d41abbc5f3b1d5480c19">&#9670;&nbsp;</a></span>starts_with_nocase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gul14::starts_with_nocase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a string starts with another string. </p>
<p>The comparison is case insensitive as far as ASCII characters are concerned (C locale). If the searched-for prefix is empty, the result is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The full string to be tested. </td></tr>
    <tr><td class="paramname">prefix</td><td>The prefix to be looked for at the beginning of <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>str</code> starts with <code>prefix</code>, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a1d5572dd02a7d92918dde5f75c18f559" title="Determine whether a string starts with a certain character.">starts_with_nocase(string_view, char)</a>, <a class="el" href="namespacegul14.html#ad85883e07b4ec2e653b4fb255f4f04b8" title="Determine whether a string starts with another string.">starts_with(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#aad247f13c1c43036097c549f043c30fe" title="Determine whether a string ends with another string.">ends_with_nocase(string_view, string_view)</a>, <a class="el" href="namespacegul14.html#a9913fd6012b85d8c0d4d51c0478c5164" title="Determine whether a string contains another string.">contains_nocase(string_view, string_view)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052">lowercase_ascii()</a>.</p>

</div>
</div>
<a id="a4074913afff7c8698358785771ab61db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4074913afff7c8698358785771ab61db">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gul14::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange the contents of one <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with those of another one. </p>
<p>If either this or the other vector have internally stored elements (capacity() &lt;= inner_capacity()), this function falls back to element-wise swapping. Otherwise, the heap-allocated buffers are swapped directly. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a6ac0fa47638f2ad8e70172fa71fcbd77">gul14::SmallVector&lt; ElementT, in_capacity &gt;::swap()</a>.</p>

</div>
</div>
<a id="af863dc04f4588482947e31f758762b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af863dc04f4588482947e31f758762b89">&#9670;&nbsp;</a></span>tic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::steady_clock::time_point gul14::tic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current time as a std::chrono time_point. </p>
<p>This function is intended to be used with the sister function <a class="el" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e" title="Return the elapsed time in seconds (or a different unit) since the given time point.">toc()</a> to measure elapsed time.</p>
<h4>Example</h4>
<div class="fragment"><div class="line"><span class="keyword">auto</span> t0 = <a class="code" href="namespacegul14.html#af863dc04f4588482947e31f758762b89">tic</a>();</div>
<div class="line"><span class="comment">// Do some work</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Elapsed time: &quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e">toc</a>(t0) &lt;&lt; <span class="stringliteral">&quot; seconds.\n&quot;</span>;</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e" title="Return the elapsed time in seconds (or a different unit) since the given time point.">toc()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e">toc()</a>.</p>

</div>
</div>
<a id="a1b503aeb7d32d9e9582d4115975c72f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b503aeb7d32d9e9582d4115975c72f7">&#9670;&nbsp;</a></span>to_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , std::enable_if_t&lt; std::is_integral&lt; NumberType &gt;::value &amp;&amp;std::is_unsigned&lt; NumberType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1optional.html">optional</a>&lt; NumberType &gt; gul14::to_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an ASCII string_view into a number. </p>
<p>This function parses the ASCII representation of a number (e.g. "123" or "1.3e10") into an optional integer or floating-point number.</p>
<div class="fragment"><div class="line"><a class="code" href="classgul14_1_1optional.html">gul14::optional&lt;int&gt;</a> result = gul14::to_number&lt;int&gt;(<span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (result.has_value())</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The answer is &quot;</span> &lt;&lt; result.value() &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (result)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The answer is &quot;</span> &lt;&lt; *result &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>;</div>
</div><!-- fragment --><h4>Design Goals</h4>
<p><a class="el" href="namespacegul14.html#a1b503aeb7d32d9e9582d4115975c72f7" title="Convert an ASCII string_view into a number.">to_number()</a> shares many characteristics with std::atoi(), std::stod() and the like, but follows its own set of design goals:</p><ul>
<li>Its input type is string_view: No null-termination and no temporary std::string are required for the conversion.</li>
<li>Conversion errors are reported by returning a <a class="el" href="classgul14_1_1optional.html" title="A class template that can either contain a value of a certain type or not.">gul14::optional</a> without a value.</li>
<li>The function does not allocate.</li>
<li>Performance should in most cases be better than and in few cases not much worse than std::sto[ildf].</li>
<li><a class="el" href="namespacegul14.html#a1b503aeb7d32d9e9582d4115975c72f7" title="Convert an ASCII string_view into a number.">to_number&lt;&gt;()</a> can be used in a constexpr context <em>if</em> the compiler and standard library support this. Support for floating-point numbers may lack even if integer conversion works.</li>
</ul>
<h4>Input Format</h4>
<p>The allowed number format depends on the chosen numeric output type. </p><h5>Unsigned integral types</h5>
<ul>
<li>Accept only digits ("123", "042"=42).</li>
</ul>
<h5>Signed integral types</h5>
<ul>
<li>Allow additionally a leading minus sign as well ("-42"). No leading plus sign is allowed, though.</li>
</ul>
<h5>Floating-point types</h5>
<p>Recognize additionally</p><ul>
<li>A decimal point ("1.2", ".5", "12.") and exponential notation using a small or capital "e" ("12e5", "4.2e1", ".2e-4", "2.E5").</li>
<li>Infinity expressions: (optional minus sign) INF or INFINITY ignoring case.</li>
<li>Not-a-number expressions: (optional minus sign) NAN or NAN(char_sequence) ignoring case. The char_sequence can only contain digits, Latin letters, and underscores. The result is a quiet NaN floating-point value.</li>
</ul>
<p>The behavior with surrounding whitespace is <em>undefined</em>, so it should be removed before passing input to this function. This means <a class="el" href="namespacegul14.html#a1b503aeb7d32d9e9582d4115975c72f7" title="Convert an ASCII string_view into a number.">to_number()</a> accepts a subset of C++17's from_chars() input format; where it supports the input format it is modeled close to from_chars().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumberType</td><td>Destination numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be converted into a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgul14_1_1optional.html" title="A class template that can either contain a value of a certain type or not.">gul14::optional</a> that contains the number if the conversion was successful. If there was a conversion error, the return value is empty. If the input describes a number whose parsed value is not in the range representable by <b>NumberType</b>, the return value is empty.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has different overloads for unsigned integers, signed integers, and floating-point types. </dd>
<dd>
The floating-point overload allocates an intermediate string if<ul>
<li>the intermediate integer type is too small in comparison to NumberType or</li>
<li>this function is used with long double on Apple Clang.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.6 </dd>
<dd>
GUL version 1.7 the NAN and INF floating point conversion </dd></dl>

</div>
</div>
<a id="a093e46ff24705fce82ca32121620a54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e46ff24705fce82ca32121620a54e">&#9670;&nbsp;</a></span>toc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TimeUnitType  = std::chrono::duration&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul14::toc </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>t0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elapsed time in seconds (or a different unit) since the given time point. </p>
<p>This function is intended to be used with the sister function <a class="el" href="namespacegul14.html#af863dc04f4588482947e31f758762b89" title="Return the current time as a std::chrono time_point.">tic()</a> to measure elapsed time. <a class="el" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e" title="Return the elapsed time in seconds (or a different unit) since the given time point.">toc()</a> is a function template that returns the elapsed seconds as a double value by default; by specifying a different <code>chrono</code> type as a template parameter, it can also return other time units and other types.</p>
<h4>Example</h4>
<div class="fragment"><div class="line"><span class="keyword">auto</span> t0 = <a class="code" href="namespacegul14.html#af863dc04f4588482947e31f758762b89">tic</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &lt;do some work&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Default: Return seconds as a double</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Elapsed time: &quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e">toc</a>(t0) &lt;&lt; <span class="stringliteral">&quot; seconds.\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom type: Return milliseconds as an integer</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Elapsed time: &quot;</span> &lt;&lt; toc&lt;std::chrono::milliseconds&gt;(t0) &lt;&lt; <span class="stringliteral">&quot; milliseconds.\n&quot;</span>;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TimeUnitType</td><td>The type to be used for calculating the elapsed time since t0. By default, this is std::chrono::duration&lt;double&gt;, which means that the elapsed time is returned as a double that represents seconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>A time point in the past that should be taken with <a class="el" href="namespacegul14.html#af863dc04f4588482947e31f758762b89" title="Return the current time as a std::chrono time_point.">tic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the elapsed time in the units and base representation of TimeUnitType. By default, this is a double that represents elapsed seconds. For a TimeUnitType of std::chrono::milliseconds, it would be an integer representing elapsed milliseconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#af863dc04f4588482947e31f758762b89" title="Return the current time as a std::chrono time_point.">tic()</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#af863dc04f4588482947e31f758762b89">tic()</a>.</p>

</div>
</div>
<a id="aa8e8600a02fd663c746353934b0e224c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e8600a02fd663c746353934b0e224c">&#9670;&nbsp;</a></span>tokenize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringContainer gul14::tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>delimiters</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerInsertFct&#160;</td>
          <td class="paramname"><em>insert_fct</em> = <code>detail::emplace_back&lt;StringContainer&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the given string into a vector of substrings (tokens) delimited by any of the characters in the delimiters string. </p>
<p>Multiple adjacent delimiters are treated like a single one, and delimiters at the beginning and end of the string are ignored. For example, tokenize("   A  B C  ") yields a vector with the three entries "A", "B", and "C".</p>
<div class="fragment"><div class="line"><span class="comment">// Default return type std::vector&lt;std::string&gt;</span></div>
<div class="line"><span class="keyword">auto</span> tokens = <a class="code" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c">tokenize</a>(<span class="stringliteral">&quot;  Hello world  &quot;</span>);</div>
<div class="line">assert(tokens.size() == 2);</div>
<div class="line">assert(tokens[0] == <span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">assert(tokens[1] == <span class="stringliteral">&quot;world&quot;</span>);</div>
</div><!-- fragment --><p>This function returns a <code>std::vector&lt;std::string&gt;</code> by default, but a compatible container for string/string_view types can be specified via a template parameter:</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringContainer</td><td>A container for strings or string_view-like types, e.g. std::vector&lt;std::string&gt; or std::list&lt;gul14::string_view&gt; </td></tr>
    <tr><td class="paramname">ContainerInsertFct</td><td>Type for the <code>insert_fct</code> function parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be split. </td></tr>
    <tr><td class="paramname">delimiters</td><td>String with delimiter characters. Any of the characters in this string marks the beginning/end of a token. By default, a wide variety of whitespace and control characters is used. </td></tr>
    <tr><td class="paramname">insert_fct</td><td>By default, <a class="el" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c" title="Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...">tokenize()</a> calls the <code>emplace_back()</code> member function on the container to insert strings. This parameter may contain a different function pointer or object with the signature <code>void f(StringContainer&amp;, gul14::string_view)</code> that is called instead. This can be useful for containers that do not provide <code>emplace_back()</code> or for other customizations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container with the single substrings.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Return string_views instead of strings (like tokenize_sv())</span></div>
<div class="line"><span class="keyword">auto</span> parts1 = tokenize&lt;std::vector&lt;gul14::string_view&gt;&gt;(<span class="stringliteral">&quot;Hello world&quot;</span>);</div>
<div class="line">assert(parts1.size() == 2);</div>
<div class="line">assert(parts1[0] == <span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">assert(parts1[1] == <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use a different container that provides emplace_back()</span></div>
<div class="line"><span class="keyword">auto</span> parts2 = tokenize&lt;gul14::SmallVector&lt;gul14::string_view, 3&gt;&gt;(<span class="stringliteral">&quot;a-b-c&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>);</div>
<div class="line">assert(parts2.size() == 3);</div>
<div class="line">assert(parts2[0] == <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">assert(parts2[1] == <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">assert(parts2[2] == <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use a different container with a custom inserter function</span></div>
<div class="line"><span class="keyword">using</span> WeirdContainer = std::queue&lt;std::string&gt;;</div>
<div class="line"><span class="keyword">auto</span> inserter = [](WeirdContainer&amp; c, <a class="code" href="classgul14_1_1basic__string__view.html">gul14::string_view</a> sv) { c.emplace(sv); };</div>
<div class="line"><span class="keyword">auto</span> parts3 = tokenize&lt;WeirdContainer&gt;(<span class="stringliteral">&quot;a.b&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, inserter);</div>
<div class="line">assert(parts3.size() == 2);</div>
<div class="line">assert(parts3.front() == <span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">assert(parts3.back() == <span class="stringliteral">&quot;b&quot;</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c" title="Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...">tokenize()</a> does not assume a specific encoding for its input strings, but operates on individual <code>char</code>s. This can have surprising effects in code such as this: <div class="fragment"><div class="line"><span class="keyword">auto</span> words = <a class="code" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c">tokenize</a>(<span class="stringliteral">&quot;Hörgeräteakkustiker hätten es gewußt&quot;</span>, <span class="stringliteral">&quot;ä&quot;</span>);</div>
<div class="line">assert(words.size() == 3); <span class="comment">// Might fail or succeed depending on the encoding</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a419d994c05e195f77821b1253b8aaf36" title="Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...">gul14::tokenize_sv()</a> returns a vector&lt;string_view&gt; by default, <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">gul14::split()</a> uses a different approach to string splitting.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.5, the return type of <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">split()</a> can be specified as a template parameter and a custom inserter can be specified (it always returned std::vector&lt;std::string&gt; before). </dd></dl>

</div>
</div>
<a id="a419d994c05e195f77821b1253b8aaf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d994c05e195f77821b1253b8aaf36">&#9670;&nbsp;</a></span>tokenize_sv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringContainer  = std::vector&lt;string_view&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, string_view)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringContainer gul14::tokenize_sv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>delimiters</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerInsertFct&#160;</td>
          <td class="paramname"><em>insert_fct</em> = <code>detail::emplace_back&lt;StringContainer&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the given string into a vector of substrings (tokens) delimited by any of the characters in the delimiters string. </p>
<p>This function is identical to <a class="el" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c" title="Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...">tokenize(string_view, string_view, ContainerInsertFct)</a> except that it returns a std::vector of string_views instead of strings by default: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tokens = <a class="code" href="namespacegul14.html#a419d994c05e195f77821b1253b8aaf36">tokenize_sv</a>(<span class="stringliteral">&quot;hello world&quot;</span>, <span class="stringliteral">&quot; &quot;</span>); <span class="comment">// Return type is std::vector&lt;gul14::string_view&gt;</span></div>
<div class="line">assert(tokens.size() == 2);</div>
<div class="line">assert(tokens[0] == <span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line">assert(tokens[1] == <span class="stringliteral">&quot;world&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c" title="Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...">gul14::tokenize()</a> returns a vector&lt;string&gt; by default, <a class="el" href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9" title="Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...">gul14::split()</a> uses a different approach to string splitting.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.5, the return type of <a class="el" href="namespacegul14.html#a419d994c05e195f77821b1253b8aaf36" title="Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...">tokenize_sv()</a> can be specified as a template parameter and a custom inserter can be specified (it always returned std::vector&lt;gul14::string_view&gt; before). </dd></dl>

</div>
</div>
<a id="a0af285e7ea3b0a077734c00e2059f330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af285e7ea3b0a077734c00e2059f330">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>ws_chars</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading and trailing whitespace (or a custom set of characters) from a string, returning a new std::string. </p>
<p>Which characters are removed can be customized via the ws_chars parameter.</p>
<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330">trim</a>(<span class="stringliteral">&quot;\n \b trim(), default whitespace\t \r&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[trim(), default whitespace]&quot;</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330">trim</a>(<span class="stringliteral">&quot;.:.:.:trim(), custom whitespace.:.:.:.&quot;</span>, <span class="stringliteral">&quot;.:&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[trim(), custom whitespace]&quot;</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string that should be trimmed. </td></tr>
    <tr><td class="paramname">ws_chars</td><td>A string containing all the characters that should be treated as whitespace (i.e. that are trimmed). If this is empty, no characters are trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a trimmed copy of the input string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim_sv()</a> returns a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a> instead of a copied string,<br  />
 <a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e" title="Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_left()</a> and <a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_right()</a> trim only one side of the string,<br  />
 <a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b" title="Trim leading whitespace (or a custom set of characters) from a string, returning a view into the orig...">trim_left_sv()</a> and <a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the ori...">trim_right_sv()</a> trim only one side and return a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="trim_8cc-example.html#a0">trim.cc</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e">trim_sv()</a>.</p>

</div>
</div>
<a id="a79cfeb1eb167325b12ba86a65dc04f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cfeb1eb167325b12ba86a65dc04f3e">&#9670;&nbsp;</a></span>trim_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::trim_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>ws_chars</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string. </p>
<p>Which characters are removed can be customized via the ws_chars parameter.</p>
<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e">trim_left</a>(<span class="stringliteral">&quot;\n \b trim_left(), default whitespace   &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[trim_left(), default whitespace   ]&quot;</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb">trim_right</a>(<span class="stringliteral">&quot;.:.:.:trim_right(), custom whitespace.:.:.:.&quot;</span>, <span class="stringliteral">&quot;.:&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[.:.:.:trim_right, custom whitespace]&quot;</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string from which leading characters should be trimmed. </td></tr>
    <tr><td class="paramname">ws_chars</td><td>A string containing all the characters that should be treated as whitespace (i.e. that are trimmed). If this is empty, no characters are trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a trimmed copy of the input string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b" title="Trim leading whitespace (or a custom set of characters) from a string, returning a view into the orig...">trim_left_sv()</a> returns a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a> instead of a copied string,<br  />
 <a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_right()</a> and <a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the ori...">trim_right_sv()</a> trim the other side of the string,<br  />
 <a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim()</a> and <a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim_sv()</a> trim both sides of the string. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="trim_8cc-example.html#a1">trim.cc</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b">trim_left_sv()</a>.</p>

</div>
</div>
<a id="afaa3db5afdef851e15185589aaacb16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa3db5afdef851e15185589aaacb16b">&#9670;&nbsp;</a></span>trim_left_sv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> gul14::trim_left_sv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>ws_chars</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading whitespace (or a custom set of characters) from a string, returning a view into the original string. </p>
<p>Which characters are removed can be customized via the ws_chars parameter.</p>
<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b">trim_left_sv</a>(<span class="stringliteral">&quot;\n \b trim_left_sv(), default whitespace   &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[trim_left_sv(), default whitespace   ]&quot;</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1">trim_right_sv</a>(<span class="stringliteral">&quot;.:.:.:trim_right_sv(), custom whitespace.:.:.:.&quot;</span>, <span class="stringliteral">&quot;.:&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[.:.:.:trim_right_sv, custom whitespace]&quot;</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string from which leading characters should be trimmed. </td></tr>
    <tr><td class="paramname">ws_chars</td><td>A string containing all the characters that should be treated as whitespace (i.e. that are trimmed). If this is empty, no characters are trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a trimmed string_view that points into the input string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e" title="Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_left()</a> returns a copied string instead of a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a>,<br  />
 <a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_right()</a> and <a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the ori...">trim_right_sv()</a> trim the other side of the string,<br  />
 <a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim()</a> and <a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim_sv()</a> trim both sides of the string. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="trim_8cc-example.html#a3">trim.cc</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e">trim_left()</a>.</p>

</div>
</div>
<a id="af75ce67592c33fda6f431085747b21cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75ce67592c33fda6f431085747b21cb">&#9670;&nbsp;</a></span>trim_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::trim_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>ws_chars</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string. </p>
<p>Which characters are removed can be customized via the ws_chars parameter.</p>
<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e">trim_left</a>(<span class="stringliteral">&quot;\n \b trim_left(), default whitespace   &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[trim_left(), default whitespace   ]&quot;</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb">trim_right</a>(<span class="stringliteral">&quot;.:.:.:trim_right(), custom whitespace.:.:.:.&quot;</span>, <span class="stringliteral">&quot;.:&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[.:.:.:trim_right, custom whitespace]&quot;</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string from which trailing characters should be trimmed. </td></tr>
    <tr><td class="paramname">ws_chars</td><td>A string containing all the characters that should be treated as whitespace (i.e. that are trimmed). If this is empty, no characters are trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a trimmed copy of the input string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the ori...">trim_right_sv()</a> returns a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a> instead of a copied string,<br  />
 <a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e" title="Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_left()</a> and <a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b" title="Trim leading whitespace (or a custom set of characters) from a string, returning a view into the orig...">trim_left_sv()</a> trim the other side of the string,<br  />
 <a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim()</a> and <a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim_sv()</a> trim both sides of the string. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="trim_8cc-example.html#a2">trim.cc</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1">trim_right_sv()</a>.</p>

</div>
</div>
<a id="a3cba61a104b118243c81a51eb72309a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba61a104b118243c81a51eb72309a1">&#9670;&nbsp;</a></span>trim_right_sv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> gul14::trim_right_sv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>ws_chars</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the original string. </p>
<p>Which characters are removed can be customized via the ws_chars parameter.</p>
<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b">trim_left_sv</a>(<span class="stringliteral">&quot;\n \b trim_left_sv(), default whitespace   &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[trim_left_sv(), default whitespace   ]&quot;</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1">trim_right_sv</a>(<span class="stringliteral">&quot;.:.:.:trim_right_sv(), custom whitespace.:.:.:.&quot;</span>, <span class="stringliteral">&quot;.:&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[.:.:.:trim_right_sv, custom whitespace]&quot;</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string from which trailing characters should be trimmed. </td></tr>
    <tr><td class="paramname">ws_chars</td><td>A string containing all the characters that should be treated as whitespace (i.e. that are trimmed). If this is empty, no characters are trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a trimmed string_view that points into the input string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_right()</a> returns a copied string instead of a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a>,<br  />
 <a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e" title="Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_left()</a> and <a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b" title="Trim leading whitespace (or a custom set of characters) from a string, returning a view into the orig...">trim_left_sv()</a> trim the other side of the string,<br  />
 <a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim()</a> and <a class="el" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim_sv()</a> trim both sides of the string. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="trim_8cc-example.html#a4">trim.cc</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb">trim_right()</a>.</p>

</div>
</div>
<a id="a8d4755d57b125523fefbadf2b4f6773e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4755d57b125523fefbadf2b4f6773e">&#9670;&nbsp;</a></span>trim_sv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> gul14::trim_sv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>ws_chars</em> = <code><a class="el" href="namespacegul14.html#a2dfe9f0d3222edbf1ddab35d9d452e4f">default_whitespace_characters</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading and trailing whitespace (or a custom set of characters) from a string, returning a view into the original string. </p>
<p>Which characters are removed can be customized via the ws_chars parameter.</p>
<div class="fragment"><div class="line">    std::string str = <span class="stringliteral">&quot;  string_view  &quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> sv = <a class="code" href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e">trim_sv</a>(str); <span class="comment">// sv is a string_view that points to the original string</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sv &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[string_view]&quot;</span></div>
<div class="line"> </div>
<div class="line">    str[5] = <span class="charliteral">&#39;o&#39;</span>; <span class="comment">// modify the original string</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sv &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    <span class="comment">// prints &quot;[strong_view]&quot;</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string that should be trimmed. </td></tr>
    <tr><td class="paramname">ws_chars</td><td>A string containing all the characters that should be treated as whitespace (i.e. that are trimmed). If this is empty, no characters are trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a trimmed string_view that points into the input string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330" title="Trim leading and trailing whitespace (or a custom set of characters) from a string,...">trim()</a> returns a copied string instead of a <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013" title="A view to a contiguous sequence of chars.">string_view</a>,<br  />
 <a class="el" href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b" title="Trim leading whitespace (or a custom set of characters) from a string, returning a view into the orig...">trim_left_sv()</a> and <a class="el" href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the ori...">trim_right_sv()</a> trim only one side of the string,<br  />
 <a class="el" href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e" title="Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_left()</a> and <a class="el" href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb" title="Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.">trim_right()</a> trim only one side and return a copied string.<br  />
 </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="trim_8cc-example.html#a5">trim.cc</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330">trim()</a>.</p>

</div>
</div>
<a id="a4af998808f424b8170657e47e0d2de0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af998808f424b8170657e47e0d2de0d">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> gul14::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a human readable string describing a type. </p>
<p>Cuts out the most relevant part of <code>__PRETTY_FUNCTION__</code> of itself, ignoring all the stuff that contains information on the function itself, leaving just the description of the template parameter.</p>
<p>Note: <code>__FUNCSIG__</code> with MSVC.</p>
<p>This function can only be constexpr if <code>__PRETTY_FUNCTION__</code> is constexpr. This function is not constexpr with MSVC because of language limits.</p>
<p>Use like this: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; literal = <span class="stringliteral">&quot;test&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The type is &quot;</span> &lt;&lt; gul14::type_name&lt;decltype(literal)&gt;() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type that shall be described</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string view that describes the type of the template parameter </dd></dl>

</div>
</div>
<a id="aa0b4d247d8e814c42202713e3c4272b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b4d247d8e814c42202713e3c4272b0">&#9670;&nbsp;</a></span>unescape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GUL_EXPORT std::string gul14::unescape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a>&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a string with escaped characters to get the original string back. </p>
<p>Does only know the escape sequences used by <a class="el" href="namespacegul14.html#a881f0f6e3e283fb7558eaa336020cfdf" title="Create a new string that looks like an ASCII-only C string literal of the input string.">gul14::escape()</a> and can be used as in inverse function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string with escape sequences</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string where the sequences have been evaluated</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.4 parameter <b>in</b> is a string_view (was std::string before) </dd></dl>

</div>
</div>
<a id="a917cd7027e563ab68940810b15daaa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917cd7027e563ab68940810b15daaa0a">&#9670;&nbsp;</a></span>uppercase_ascii() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char gul14::uppercase_ascii </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ASCII uppercase equivalent of the given character (or the unchanged character, if it is not an ASCII letter). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The original character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a6d3dd7d06bd977bcf832d7d9f00c9f0a" title="Return a copy of the given string in which all ASCII characters are replaced by their uppercase equiv...">uppercase_ascii(gul14::string_view)</a>, <a class="el" href="namespacegul14.html#af94d4383c549025201f317b6cce4c781" title="Replace all ASCII characters in a string by their uppercase equivalents.">uppercase_ascii_inplace(std::string &amp;)</a>, <a class="el" href="namespacegul14.html#a5dd41f38bbdde29c2a0ef7e5864d9052" title="Return the ASCII lowercase equivalent of the given character (or the unchanged character,...">lowercase_ascii(char)</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#a6d3dd7d06bd977bcf832d7d9f00c9f0a">uppercase_ascii()</a>, and <a class="el" href="namespacegul14.html#af94d4383c549025201f317b6cce4c781">uppercase_ascii_inplace()</a>.</p>

</div>
</div>
<a id="a6d3dd7d06bd977bcf832d7d9f00c9f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3dd7d06bd977bcf832d7d9f00c9f0a">&#9670;&nbsp;</a></span>uppercase_ascii() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gul14::uppercase_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">gul14::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the given string in which all ASCII characters are replaced by their uppercase equivalents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The original string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a" title="Return the ASCII uppercase equivalent of the given character (or the unchanged character,...">uppercase_ascii(char)</a>, <a class="el" href="namespacegul14.html#af94d4383c549025201f317b6cce4c781" title="Replace all ASCII characters in a string by their uppercase equivalents.">uppercase_ascii_inplace(std::string &amp;)</a>, <a class="el" href="namespacegul14.html#a9d6d216830d66a060c66ceb8e18f5e90" title="Return a copy of the given string in which all ASCII characters are replaced by their lowercase equiv...">lowercase_ascii(gul14::string_view)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a">uppercase_ascii()</a>.</p>

</div>
</div>
<a id="af94d4383c549025201f317b6cce4c781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94d4383c549025201f317b6cce4c781">&#9670;&nbsp;</a></span>uppercase_ascii_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; gul14::uppercase_ascii_inplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all ASCII characters in a string by their uppercase equivalents. </p>
<p>This function modifies the original string and returns a reference to it (which may be helpful for chaining function calls). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the string argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a" title="Return the ASCII uppercase equivalent of the given character (or the unchanged character,...">uppercase_ascii(char)</a>, <a class="el" href="namespacegul14.html#a6d3dd7d06bd977bcf832d7d9f00c9f0a" title="Return a copy of the given string in which all ASCII characters are replaced by their uppercase equiv...">uppercase_ascii(gul14::string_view)</a>, <a class="el" href="namespacegul14.html#a3cdcecf4d343173209f4bcb5fee32bff" title="Replace all ASCII characters in a string by their lowercase equivalents.">lowercase_ascii_inplace(std::string &amp;)</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a917cd7027e563ab68940810b15daaa0a">uppercase_ascii()</a>.</p>

</div>
</div>
<a id="a3a06029dccf60523519d5a22a71ac361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a06029dccf60523519d5a22a71ac361">&#9670;&nbsp;</a></span>within_abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::within_abs </td>
          <td>(</td>
          <td class="paramtype">NumT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumT&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two numbers are almost equal, allowing for an absolute difference. </p>
<p>All arguments must be the same numeric type (floating point or integer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare </td></tr>
    <tr><td class="paramname">tol</td><td>The absolute tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the absolute difference between a and b is smaller than tol. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c">abs()</a>.</p>

</div>
</div>
<a id="ac147ccba8179827a34b584d6a7d11ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac147ccba8179827a34b584d6a7d11ac9">&#9670;&nbsp;</a></span>within_orders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumT , typename OrderT , typename  = std::enable_if_t&lt;        std::is_arithmetic&lt;NumT&gt;::value        and std::is_arithmetic&lt;OrderT&gt;::value    &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::within_orders </td>
          <td>(</td>
          <td class="paramtype">const NumT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrderT&#160;</td>
          <td class="paramname"><em>orders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two numbers are almost equal, comparing only some significant digits. </p>
<p>The functions compares the specified number of significant decimal digits of the two values and returns true if they are equal within these digits. </p><pre class="fragment">a = 23736384; b = 23736228; within_orders(a, b, 5) =&gt; true  (first 5 digits equal)
a = 23736384; b = 23735384; within_orders(a, b, 5) =&gt; false (digit #5 differs)
</pre><p>Unexpected behavior can result when orders is low (&lt; 3) as the simple concept of orders equals digits does not hold so strict anymore.</p>
<p>Remember that any nonzero number has infinite different significant digits compared with 0.00000000. So if either a or b is 0.0 the result must be false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare (same type as a) </td></tr>
    <tr><td class="paramname">orders</td><td>The number of digits to take for comparison (any numeric type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the difference between a and b is orders of magnitude lower than the value of a or b.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.4 parameter type <b>NumT</b> can be an integral type (had to be floating point before) </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c">abs()</a>.</p>

</div>
</div>
<a id="a6c7886cf179298ea422806b253f0bb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7886cf179298ea422806b253f0bb0c">&#9670;&nbsp;</a></span>within_ulp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumT , typename  = std::enable_if_t&lt;std::is_floating_point&lt;NumT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gul14::within_ulp </td>
          <td>(</td>
          <td class="paramtype">NumT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ulp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two numbers are almost equal, allowing for a difference of a given number of units-in-the-last-place (ULPs). </p>
<p>One ULP is the spacing between two consecutive floating point representations. There are no possible values in between. Roughly speaking, one ULP is for floating point numbers what the 1 is for integral numbers.</p>
<p>All arguments must be of the same floating point type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare </td></tr>
    <tr><td class="paramname">ulp</td><td>Allowed number of floating point steps in between</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b are equal within the given number of ULPs. </dd></dl>

<p class="reference">References <a class="el" href="namespacegul14.html#a02e71867d1a27d723ee0c2a3bcd7761c">abs()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2dfe9f0d3222edbf1ddab35d9d452e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfe9f0d3222edbf1ddab35d9d452e4f">&#9670;&nbsp;</a></span>default_whitespace_characters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegul14.html#a6ebb24dac7ab090d9145ff49abab9013">string_view</a> gul14::default_whitespace_characters { &quot; \t\r\n\a\b\f\v&quot; }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default characters that are treated as whitespace by GUL. </p>
<p>This is a string view that contains the space and the most common control characters, namely (with their ASCII codes):</p><ul>
<li>Bell/alert (7)</li>
<li>Backspace (8)</li>
<li>Horizontal tabulator (9)</li>
<li>Newline/line feed (10)</li>
<li>Vertical Tab (11)</li>
<li>Form feed (12)</li>
<li>Carriage return (13)</li>
<li>Space (32)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The null character is not treated as whitespace by default. </dd></dl>

</div>
</div>
<a id="a8fa061a14b864c17593e03fa540d3a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa061a14b864c17593e03fa540d3a51">&#9670;&nbsp;</a></span>hex_digits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; char, 16 &gt; gul14::hex_digits</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    { <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>, <span class="charliteral">&#39;5&#39;</span>, <span class="charliteral">&#39;6&#39;</span>, <span class="charliteral">&#39;7&#39;</span>, <span class="charliteral">&#39;8&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;f&#39;</span>} }</div>
</div><!-- fragment -->
<p>The 16 digits for hexadecimal numbers ("0123456789abcdef"). </p>

<p class="reference">Referenced by <a class="el" href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">hex_string()</a>.</p>

</div>
</div>
<a id="a695805a9a6f5eeeac8d13902d23d5dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695805a9a6f5eeeac8d13902d23d5dcf">&#9670;&nbsp;</a></span>version_git</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GUL_EXPORT char const* gul14::version_git</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Holds the git version tag of the sources that the library has been build with. </p>
<p>It has the format returned by git describe &ndash;tags &ndash;always &ndash;dirty </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacegul14_html_ad3b2d42f1a3c17d56d8b4fa8dfddbf9b"><div class="ttname"><a href="namespacegul14.html#ad3b2d42f1a3c17d56d8b4fa8dfddbf9b">gul14::hexdump_stream</a></div><div class="ttdeci">HexdumpParameterForward&lt; const IteratorT &gt; hexdump_stream(const IteratorT &amp;begin, const IteratorT &amp;end, std::string prompt=&quot;&quot;)</div><div class="ttdoc">Generate a hexdump of a data range that can be efficiently written to a stream using operator&lt;&lt;.</div><div class="ttdef"><b>Definition:</b> hexdump.h:416</div></div>
<div class="ttc" id="anamespacegul14_html_a8d4755d57b125523fefbadf2b4f6773e"><div class="ttname"><a href="namespacegul14.html#a8d4755d57b125523fefbadf2b4f6773e">gul14::trim_sv</a></div><div class="ttdeci">GUL_EXPORT string_view trim_sv(string_view str, string_view ws_chars=default_whitespace_characters)</div><div class="ttdoc">Trim leading and trailing whitespace (or a custom set of characters) from a string,...</div><div class="ttdef"><b>Definition:</b> trim.cc:34</div></div>
<div class="ttc" id="anamespacegul14_html_a093e46ff24705fce82ca32121620a54e"><div class="ttname"><a href="namespacegul14.html#a093e46ff24705fce82ca32121620a54e">gul14::toc</a></div><div class="ttdeci">auto toc(std::chrono::steady_clock::time_point t0)</div><div class="ttdoc">Return the elapsed time in seconds (or a different unit) since the given time point.</div><div class="ttdef"><b>Definition:</b> time_util.h:86</div></div>
<div class="ttc" id="anamespacegul14_html_ac1b5967a0b377c9d4b3791db8e2e20a3"><div class="ttname"><a href="namespacegul14.html#ac1b5967a0b377c9d4b3791db8e2e20a3">gul14::clamp</a></div><div class="ttdeci">constexpr const NumT &amp; clamp(const NumT &amp;v, const NumT &amp;lo, const NumT &amp;hi)</div><div class="ttdoc">Coerce a value to be within a given range.</div><div class="ttdef"><b>Definition:</b> num_util.h:191</div></div>
<div class="ttc" id="anamespacegul14_html_a0e6eed5ed768613f3680866905ca82b9"><div class="ttname"><a href="namespacegul14.html#a0e6eed5ed768613f3680866905ca82b9">gul14::split</a></div><div class="ttdeci">StringContainer split(string_view text, string_view delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</div><div class="ttdoc">Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...</div><div class="ttdef"><b>Definition:</b> join_split.h:117</div></div>
<div class="ttc" id="anamespacegul14_html_af75ce67592c33fda6f431085747b21cb"><div class="ttname"><a href="namespacegul14.html#af75ce67592c33fda6f431085747b21cb">gul14::trim_right</a></div><div class="ttdeci">GUL_EXPORT std::string trim_right(string_view str, string_view ws_chars=default_whitespace_characters)</div><div class="ttdoc">Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.</div><div class="ttdef"><b>Definition:</b> trim.cc:61</div></div>
<div class="ttc" id="anamespacegul14_html_a419d994c05e195f77821b1253b8aaf36"><div class="ttname"><a href="namespacegul14.html#a419d994c05e195f77821b1253b8aaf36">gul14::tokenize_sv</a></div><div class="ttdeci">StringContainer tokenize_sv(string_view str, string_view delimiters=default_whitespace_characters, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</div><div class="ttdoc">Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...</div><div class="ttdef"><b>Definition:</b> tokenize.h:164</div></div>
<div class="ttc" id="anamespacegul14_html_a79cfeb1eb167325b12ba86a65dc04f3e"><div class="ttname"><a href="namespacegul14.html#a79cfeb1eb167325b12ba86a65dc04f3e">gul14::trim_left</a></div><div class="ttdeci">GUL_EXPORT std::string trim_left(string_view str, string_view ws_chars=default_whitespace_characters)</div><div class="ttdoc">Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.</div><div class="ttdef"><b>Definition:</b> trim.cc:46</div></div>
<div class="ttc" id="aclassgul14_1_1basic__string__view_html"><div class="ttname"><a href="classgul14_1_1basic__string__view.html">gul14::basic_string_view&lt; char &gt;</a></div></div>
<div class="ttc" id="anamespacegul14_html_aa8e8600a02fd663c746353934b0e224c"><div class="ttname"><a href="namespacegul14.html#aa8e8600a02fd663c746353934b0e224c">gul14::tokenize</a></div><div class="ttdeci">StringContainer tokenize(string_view str, string_view delimiters=default_whitespace_characters, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</div><div class="ttdoc">Split the given string into a vector of substrings (tokens) delimited by any of the characters in the...</div><div class="ttdef"><b>Definition:</b> tokenize.h:110</div></div>
<div class="ttc" id="anamespacegul14_html_a2ad9d1a1cee23214a61491bfc8171595"><div class="ttname"><a href="namespacegul14.html#a2ad9d1a1cee23214a61491bfc8171595">gul14::hexdump</a></div><div class="ttdeci">std::string hexdump(IteratorT begin, IteratorT end, string_view prompt=&quot;&quot;)</div><div class="ttdoc">Generate a hexdump of a data range and return it as a string.</div><div class="ttdef"><b>Definition:</b> hexdump.h:213</div></div>
<div class="ttc" id="anamespacegul14_html_ad64e01233c1c469a698c36c9e2f89079"><div class="ttname"><a href="namespacegul14.html#ad64e01233c1c469a698c36c9e2f89079">gul14::cat</a></div><div class="ttdeci">std::string cat()</div><div class="ttdoc">Efficiently concatenate an arbitrary number of strings and numbers.</div><div class="ttdef"><b>Definition:</b> cat.h:90</div></div>
<div class="ttc" id="anamespacegul14_html_af05731d015fe2827d95fffd6432ba74d"><div class="ttname"><a href="namespacegul14.html#af05731d015fe2827d95fffd6432ba74d">gul14::safe_string</a></div><div class="ttdeci">GUL_EXPORT std::string safe_string(const char *char_ptr, std::size_t length)</div><div class="ttdoc">Safely construct a std::string from a char pointer and a length.</div><div class="ttdef"><b>Definition:</b> string_util.cc:32</div></div>
<div class="ttc" id="aclassgul14_1_1optional_html"><div class="ttname"><a href="classgul14_1_1optional.html">gul14::optional</a></div><div class="ttdoc">A class template that can either contain a value of a certain type or not.</div><div class="ttdef"><b>Definition:</b> optional.h:272</div></div>
<div class="ttc" id="anamespacegul14_html_a06b75f0d2f5432534ce5016f4f6133e2"><div class="ttname"><a href="namespacegul14.html#a06b75f0d2f5432534ce5016f4f6133e2">gul14::mean</a></div><div class="ttdeci">auto mean(ContainerT const &amp;container, Accessor accessor=ElementAccessor&lt; ElementT &gt;()) -&gt; ResultT</div><div class="ttdoc">Calculate the arithmetic mean value of all elements in a container.</div><div class="ttdef"><b>Definition:</b> statistics.h:161</div></div>
<div class="ttc" id="anamespacegul14_html_a71226668835d574ccad136939940191f"><div class="ttname"><a href="namespacegul14.html#a71226668835d574ccad136939940191f">gul14::split_sv</a></div><div class="ttdeci">StringContainer split_sv(string_view text, string_view delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</div><div class="ttdoc">Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in ...</div><div class="ttdef"><b>Definition:</b> join_split.h:221</div></div>
<div class="ttc" id="anamespacegul14_html_a3cba61a104b118243c81a51eb72309a1"><div class="ttname"><a href="namespacegul14.html#a3cba61a104b118243c81a51eb72309a1">gul14::trim_right_sv</a></div><div class="ttdeci">GUL_EXPORT string_view trim_right_sv(string_view str, string_view ws_chars=default_whitespace_characters)</div><div class="ttdoc">Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the ori...</div><div class="ttdef"><b>Definition:</b> trim.cc:66</div></div>
<div class="ttc" id="anamespacegul14_html_adbaca240c1cd99e9a477f8c2eb8b8880"><div class="ttname"><a href="namespacegul14.html#adbaca240c1cd99e9a477f8c2eb8b8880">gul14::hex_string</a></div><div class="ttdeci">std::string hex_string(Integer v)</div><div class="ttdoc">Return the hexadecimal ASCII representation of an integer value.</div><div class="ttdef"><b>Definition:</b> string_util.h:106</div></div>
<div class="ttc" id="anamespacegul14_html_a56bfa0fde0d5eb6c3367f1d55f2504b1"><div class="ttname"><a href="namespacegul14.html#a56bfa0fde0d5eb6c3367f1d55f2504b1">gul14::standard_deviation</a></div><div class="ttdeci">auto standard_deviation(ContainerT const &amp;container, Accessor accessor=ElementAccessor&lt; ElementT &gt;()) -&gt; StandardDeviationMean&lt; ResultT &gt;</div><div class="ttdoc">Calculate the standard deviation of all elements in a container.</div><div class="ttdef"><b>Definition:</b> statistics.h:546</div></div>
<div class="ttc" id="anamespacegul14_html_af863dc04f4588482947e31f758762b89"><div class="ttname"><a href="namespacegul14.html#af863dc04f4588482947e31f758762b89">gul14::tic</a></div><div class="ttdeci">std::chrono::steady_clock::time_point tic()</div><div class="ttdoc">Return the current time as a std::chrono time_point.</div><div class="ttdef"><b>Definition:</b> time_util.h:48</div></div>
<div class="ttc" id="anamespacegul14_html_aa0abe7bf6452e6882c0e0b0d05897adc"><div class="ttname"><a href="namespacegul14.html#aa0abe7bf6452e6882c0e0b0d05897adc">gul14::sleep</a></div><div class="ttdeci">bool sleep(const std::chrono::duration&lt; Rep, Period &gt; &amp;duration, const Trigger &amp;trg)</div><div class="ttdoc">Sleep for a given time span, with the option of being woken up from another thread.</div><div class="ttdef"><b>Definition:</b> time_util.h:103</div></div>
<div class="ttc" id="anamespacegul14_html_a0af285e7ea3b0a077734c00e2059f330"><div class="ttname"><a href="namespacegul14.html#a0af285e7ea3b0a077734c00e2059f330">gul14::trim</a></div><div class="ttdeci">GUL_EXPORT std::string trim(string_view str, string_view ws_chars=default_whitespace_characters)</div><div class="ttdoc">Trim leading and trailing whitespace (or a custom set of characters) from a string,...</div><div class="ttdef"><b>Definition:</b> trim.cc:29</div></div>
<div class="ttc" id="anamespacegul14_html_afaa3db5afdef851e15185589aaacb16b"><div class="ttname"><a href="namespacegul14.html#afaa3db5afdef851e15185589aaacb16b">gul14::trim_left_sv</a></div><div class="ttdeci">GUL_EXPORT string_view trim_left_sv(string_view str, string_view ws_chars=default_whitespace_characters)</div><div class="ttdoc">Trim leading whitespace (or a custom set of characters) from a string, returning a view into the orig...</div><div class="ttdef"><b>Definition:</b> trim.cc:51</div></div>
<div class="ttc" id="anamespacegul14_html_a881f0f6e3e283fb7558eaa336020cfdf"><div class="ttname"><a href="namespacegul14.html#a881f0f6e3e283fb7558eaa336020cfdf">gul14::escape</a></div><div class="ttdeci">GUL_EXPORT std::string escape(string_view in)</div><div class="ttdoc">Create a new string that looks like an ASCII-only C string literal of the input string.</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++14 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
